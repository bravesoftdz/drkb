<html>
<head>
  <title>Загрузка DLL</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Загрузка DLL</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->

<p>Предлагаю вашему вниманию очередной выпуск рассылки, в котором я продолжаю обсуждать</p>
<p> вопросы разработки и использования DLL в Borland Delphi. Для новых подписчиков сообщаю,</p>
<p>  что первую часть статьи они могут посмотреть в архиве рассылки, выпуск номер 13. </p>
<p>  Прошу прощения у тех, кто писал мне, но не получил ответа. В ближайшее время постараюсь это исправить. </p>

<p>Итак, продолжим.</p>

<p>Загрузка DLL</p>

<p>Прежде чем начать использование какой-либо процедуры или функции, находящейся в динамической библиотеке, </p>
<p>вам необходимо загрузить DLL в оперативную память. Загрузка библиотеки может быть осуществлена </p>
<p>одним из двух способов: статическая загрузка и динамическая загрузка.</p>
<p> Оба метода имеют как преимущества, так и недостатки. </p>

<p>Статическая загрузка означает, что динамическая библиотека загружается автоматически </p>
<p>при запуске на выполнение использующего ее приложения. Для того чтобы использовать такой способ загрузки, </p>
<p>вам необходимо воспользоваться ключевым словом external при описании экспортируемой из</p>
<p> динамической библиотеки функции или процедуры. DLL автоматически загружается при старте программы,</p>
<p>  и Вы сможете использовать любые экспортируемые из нее подпрограммы точно так же,</p>
<p>  как если бы они были описаны внутри модулей приложения. </p>
<p>  Это наиболее легкий способ использования кода, помещенного в DLL . </p>
<p>  Недостаток метода заключается в том, что если файл библиотеки, на который</p>
<p>  имеется ссылка в приложении, отсутствует, программа откажется загружаться.</p>

<p>Смысл динамического метода заключается в том, что вы загружаете библиотеку не при старте приложения, </p>
<p>а в тот момент, когда вам это действительно необходимо. Сами посудите, ведь если функция, описанная </p>
<p>в динамической библиотеке, используется только при 10% запусков программы, то совершенно нет </p>
<p>смысла использовать статический метод загрузки. Выгрузка библиотеки из памяти в данном случае </p>
<p>также осуществляется под вашим контролем. Еще одно преимущества такого способа </p>
<p>загрузки DLL - это уменьшение (по понятным причинам) времени старта вашего приложения. </p>
<p>А какие же у этого способа имеются недостатки? Основной, как мне кажется, - это то, что использование</p>
<p> данного метода является более хлопотным, чем рассмотренная выше статическая загрузка.</p>
<p>  Сначала вам необходимо воспользоваться функцией Windows API LoadLibrary . </p>
<p>  Для получения указателя на экспортируемой процедуры или функции должна </p>
<p>  использоваться функция GetProcAddress. После завершения использования библиотеки DLL </p>
<p>  должна быть выгружена с применением FreeLibrary.</p>

<p>Вызов процедур и функций, загруженных из DLL.</p>

<p>Способ вызова процедур и функций зависит от того, каким образом вы загрузили динамическую библиотеку, </p>
<p>в которой эти подпрограммы находятся.</p>

<p>Вызов функций и процедур из статически загруженных DLL достаточно прост. Первоначально в приложении </p>
<p>должно содержаться описание экспортируемой функции (процедуры). После этого вы можете их использовать</p>
<p> точно так же, как если бы они были описаны в одном из модулей вашего приложения. </p>
<p>Для импорта функции или процедуры, содержащейся в DLL , необходимо использовать</p>
<p> модификатор external в их объявлении. К примеру, для рассмотренной нами выше процедуры HelloWorld</p>
<p> в вызывающем приложении должна быть помещена следующая строка:</p>

<p>procedure SayHello(AForm : TForm); external myfirstdll.dll';</p>
<p>Ключевое слово external сообщает компилятору, что данная процедура может быть найдена в</p>
<p> динамической библиотеке (в нашем случае - myfirstdll.dll). </p>
<p>Далее вызов этой процедуры выглядит следующим образом:</p>

<p>...</p>
<p>HelloWorld(self);</p>
<p> ...</p>

<p>При импорте функции и процедур будьте особенно внимательны при написании их имен и интерфейсов!</p>
<p> Дело в том, что в процессе компиляции приложения не производится проверки на правильность имен объектов, </p>
<p>экспортируемых из DLL, осуществляться не будет, и если вы неправильно описали какую-нибудь функцию, </p>
<p>то исключение будет сгенерировано только на этапе выполнения приложения.</p>

<p>Импорт из DLL может проводиться по имени процедуры (функции), порядковому номеру или </p>
<p>с присвоением другого имени.</p>

<p>В первом случае вы просто объявляете имя процедуры и библиотеку, из которой ее импортируете</p>
<p> (мы это рассмотрели чуть выше). Импорт по порядковому номеру требует от вас указание этого самого номера: </p>
&nbsp;
procedure HelloWorld(AForm : TForm); external myfirstdll.dll index 15;

<p>В этом случае имя, которое вы даете процедуре при импорте не обязательно должно совпадать с тем,</p>
<p> которое было указано для нее в самой DLL. Т.е. приведенная выше запись означает,</p>
<p>что вы импортируете из динамической библиотеки myfirstdll.dll процедуру, которая в ней экспортировалась</p>
<p> пятнадцатой, и при этом в рамках вашего приложения этой процедуре дается имя SayHello.</p>

<p>Если вы по каким-то причинам не применяете описанный выше способ импорта, </p>
<p>но тем не менее хотите изменить имя импортируемой функции (процедуры), то можно воспользоваться третьим методом: </p>
&nbsp;
procedure CoolProcedure;&nbsp; external myfirstdll.dll name 'DoSomethingReallyCool';

<p>Здесь импортируемой процедуре CoolProcedure дается имя DoSomethingReallyCool.</p>
<p>Вызов процедур и функций, импортируемых из динамически загружаемых библиотек </p>
<p>несколько более сложен, чем рассмотренный нами выше способ. В данном случае требуется объявить</p>
<p> указатель на функцию или процедуру, которую вы собираетесь использовать.</p>
<p> Помните процедуру HelloWorld? Давайте посмотрим, что необходимо сделать для того,</p>
<p> чтобы вызвать ее на выполнение в случае динамической загрузки DLL. Во-первых, вам </p>
<p>необходимо объявить тип, который описывал бы эту процедуру:</p>

<p>type</p>
<p>  THelloWorld = procedure(AForm : TForm);</p>

<p>Теперь вы должны загрузить динамическую библиотеку, с помощью GetProcAddress получить </p>
<p>указатель на процедуру, вызвать эту процедуру на выполнение, и, наконец, выгрузить DLL из памяти. </p>
<p>Ниже приведен код, демонстрирующий, как это можно сделать:</p>
<pre name="code" class="delphi">
var
  DLLInstance : THandle;
  HelloWorld : THelloWorld;
begin
  { загружаем DLL }
  DLLInstance := LoadLibrary('myfirstdll.dll');
  { получаем указатель }
  @HelloWorld := GetProcAddress(DLLInstance, 'HelloWorld');
  { вызываем процедуру на выполнение }  
  HelloWorld(Self);
  { выгружаем DLL из оперативной памяти }
  FreeLibrary(DLLInstance);
end;
</pre>


<p>Как уже говорилось выше, одним из недостатков статической загрузки DLL является невозможность </p>
<p>продолжения работы приложения при отсутствии одной или нескольких библиотек. В случае с динамической</p>
<p> загрузкой у вас появляется возможность программно обрабатывать такие ситуации и не допускать, чтобы программа </p>
<p>вываливалась» самостоятельно. По возвращаемому функциями LoadLibrary и GetProcAddress значениям можно</p>
<p> определить, успешно ли прошла загрузка библиотеки и найдена ли в ней необходимая приложению процедура.</p>
<p> Приведенный ниже код демонстрирует это. </p>
<pre name="code" class="delphi">
procedure TForm1.DynamicLoadBtnClick(Sender: TObject);
type
  THelloWorld = procedure(AForm : TForm);
var
  DLLInstance : THandle;
  HelloWorld : THelloWorld;
begin
  DLLInstance := LoadLibrary('myfirstdll.dll');
  if DLLInstance = 0 then begin
    MessageDlg('Невозможно загрузить DLL', mtError, [mbOK], 0);
    Exit;
  end;
  @HelloWorld := GetProcAddress(DLLInstance, 'HelloWorld');
  if @HelloWorld  nil then
    HelloWorld (Self)
  else
    MessageDlg('Не найдена искомая процедура!.', mtError, [mbOK], 0);
  FreeLibrary(DLLInstance);
end;
</pre>


<p>В DLL можно хранить не только код, но и формы. </p>
<p>Причем создание и помещение форм в динамическую библиотеку не слишком сильно отличается от работы</p>
<p> с формами в обычном проекте. Сначала мы рассмотрим, каким образом можно написать библиотеку, </p>
<p>содержащую формы, а затем мы поговорим об использовании технологии MDI в DLL. </p>

<p>Разработку DLL, содержащую форму, я продемонстрирую на примере.</p>

<p>Итак, во-первых, создадим новый проект динамической библиотеки.</p>
<p> Для этого выберем пункт меню File|New, а затем дважды щелкнем на иконку DLL .</p>
<p> После этого вы увидите примерно следующий код:</p>
<pre name="code" class="delphi">
library Project2;
{здесь были комментарии}
 
uses
  SysUtils,
  Classes;
 
{$R *.RES}
 
begin
end.
</pre>

<p>Сохраните полученный проект. Назовем его DllForms.dpr.</p>

<p>Теперь следует создать новую форму. Это можно сделать по-разному.</p>
<p> Например, выбрав пункт меню File|New Form. Добавьте на форму какие-нибудь компоненты. </p>
<p>Назовем форму DllForm и сохраним получившийся модуль под именем DllFormUnit.pas .</p>

<p>Вернемся к главному модулю проекта и поместим в него функцию ShowForm, в задачу которой будет входить</p>
<p> создание формы и ее вывод на экран. Используйте для этого приведенный ниже код.</p>
<pre name="code" class="delphi">
function ShowForm : Integer; stdcall;
var
  Form : TDLLForm;
begin
  Form := TDLLForm.Create(Application);
  Result := Form.ShowModal;
  Form.Free;
end;
</pre>


<p>Обращаю внимание, что для того, чтобы проект был скомпилирован без ошибок, необходимо добавить в секцию uses модуль Forms .</p>

<p>Экспортируем нашу функцию с использованием ключевого слова exports :</p>

<p>exports</p>
<p>  ShowForm;</p>

<p>Компилируем проект и получаем файл dllforms.dll. Эти простые шаги - все,</p>
<p> что необходимо сделать для сОбратите внимание, что функция ShowForm объявлена с использованием ключевого слова stdcall .</p>
<p> Оно сигнализирует компилятору использовать при экспорте функции соглашение</p>
<p> по стандартному вызову (standard call calling convention). Экспорт функции таким образом создает </p>
<p>возможность использования разработанной DLL не только в приложениях, созданных в Delphi.</p>

<p>Соглашение по вызову (Calling conventions) определяет, каким образом передаются аргументы при вызове функции. </p>
<p>Существует пять основных соглашений: stdcall, cdecl, pascal, register и safecall. </p>
<p>Подробнее об этом можно узнать, посмотрев раздел " Calling Conventions " в файле помощи Delphi.</p>

<p>Также обратите внимание, что значение, возвращаемое функцией ShowForm ,</p>
<p> соответствует значению ShowModal. Таким образом вы можете передавать некоторую информацию</p>
<p> о состоянии формы вызывающему приложению.</p>

<p>Ниже представлено два листинга, первый из которых содержит полный код файла </p>
<p>проекта DLL (модуль с формой здесь не приводится), а второй - модуль вызывающего приложения, </p>
<p>в котором используется только что разработанная нами библиотека.</p>
<pre name="code" class="delphi">
library DllForms;
 
uses
  SysUtils,
  Classes,
  Forms,
  DllFormUnit in 'DllFormUnit.pas' {DllForm};
 
{$R *.RES}
 
function ShowForm : Integer; stdcall;
var
  Form : TDLLForm;
begin
  Form := TDLLForm.Create(Application);
  Result := Form.ShowModal;
  Form.Free;
end;
 
begin
end.
</pre>

<pre name="code" class="delphi">
unit TestAppUnit;
interface
uses
  Windows, Messages, SysUtils, Classes, Graphics,
  Controls, Forms, Dialogs, StdCtrls;
type
  TForm1 = class(TForm)
    Button1: TButton;
    procedure Button1Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;
var
  Form1: TForm1;
function ShowForm : Integer; stdcall;
  external 'dllforms.dll';
implementation
{$R *.DFM}
procedure TForm1.Button1Click(Sender: TObject);
begin
  ShowForm;
end;
end.
</pre>


<p>Прошу заметить, что при экспорте функции также было использовано ключевое слово stdcall.</p>

<p>Следует обратить особое внимание на работу с дочерними формами в DLL. Если, к примеру,</p>
<p> в вызывающем приложении главная форма имеет значение свойства FormStyle, равным MDIForm, </p>
<p>то при попытке вызова из DLL MDIChild-формы, на экране появится сообщение об ошибке, </p>
<p>в котором будет говориться, что нет ни одной активной MDI-формы. </p>

<p>В тот момент, когда вы пытаетесь показать ваше дочернее окно, VCL проверяет корректность </p>
<p>свойства FormStyle главной формы приложения. Однако в нашем случае все вроде бы верно. </p>
<p>Так в чем же дело? Проблема в том, что при проведении такой проверки, рассматривается объект Application, </p>
<p>принадлежащий не вызывающему приложению, а собственно динамической библиотеке.</p>
<p> Ну, и естественно, поскольку в DLL нет главной формы, проверка выдает ошибку.</p>
<p> Для того чтобы избежать такой ситуации, надо назначить объекту Application динамической библиотеки</p>
<p> объект Application вызывающего приложения. Естественно, это заработает только в том случае,</p>
<p>когда вызывающая программа - VCL-приложение. Кроме того, перед выгрузкой библиотеки из памяти</p>
<p> необходимо вернуть значение объекта Application библиотеки в первоначальное состояние. </p>
<p>Это позволит менеджеру памяти очистить оперативную память, занимаемую библиотекой.</p>
<p> Следовательно, вам нужно сохранить указатель на «родной» для библиотеки объект Application </p>
<p>в глобальной переменной, которая может быть использована при восстановлении его значения. </p>

<p>Итак, вернемся немного назад и перечислим шаги, необходимые нам для работы с помещенным</p>
<p> в DLL MDIChild-формами. </p>

<p>В динамической библиотеке создаем глобальную переменную типа TApplication. </p>
<p>Сохраняем указатель на объект Application DLL в глобальной переменной. </p>
<p>Объекту Application динамической библиотеки ставим в соответствие указатель на Application</p>
<p> вызывающего приложения. </p>
<p>Создаем MDIChild-форму и работаем с ней. </p>
<p>Возвращаем в первоначальное состояние значение объекта Application динамической библиотеки</p>
<p> и выгружаем DLL из памяти. </p>
<p>Первый шаг прост. Просто помещаем следующий код в верхней части модуля DLL: </p>

<p>var</p>
<p>  DllApp : TApplication;</p>

<p>Затем создаем процедуру, которая будет изменять значение объекта Application и создавать дочернюю форму.</p>
<p> Процедура может выглядеть примерно так:</p>
<pre name="code" class="delphi">
procedure ShowMDIChild(MainApp : TApplication);
var
  Child : TMDIChild;
begin
  if not Assigned(DllApp) then begin
    DllApp := Application;
    Application := MainApp;
  end;
  Child := TMDIChild.Create(Application.MainForm);
  Child.Show;
end;
</pre>


<p>Все, что нам теперь необходимо сделать, - это предусмотреть возвращение значения объекта Application</p>
<p> в исходное состояние. Делаем это с помощью процедуры MyDllProc: </p>
<pre name="code" class="delphi">
procedure MyDLLProc(Reason: Integer);
begin
  if Reason = DLL_PROCESS_DETACH then
    { DLL is выгружается. Восстанавливаем значение указателя Application}
    if Assigned(DllApp) then
      Application := DllApp;
end;
</pre>


<p>Вместо заключения. </p>

<p>Использование динамически подключаемых библиотек не так сложно, как это может показаться на первый взгляд. </p>
<p>DLL предоставляют широчайшие возможности для оптимизации работы приложений,</p>
<p> а также работы самих программистов.&nbsp; Используйте DLL и, возможно, ваша жизнь станет легче!</p>

<p>Использование динамически подключаемых библиотек не так сложно, как это может показаться на первый взгляд.</p>
<p>DLL предоставляют широчайшие возможности для оптимизации работы приложений,</p>
<p> а также работы самих программистов.&nbsp; Используйте DLL и, возможно, ваша жизнь станет легче!</p>
<p>http://subscribe.ru/ </p>
<p>E-mail: ask@subscribe.ru&nbsp; Поиск&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>на АПОРТ&nbsp;&nbsp;&nbsp; на Subscribe.Ru&nbsp; </p>

<p>Взято с сайта <a href="http://blackman.wp-club.net/" target="_blank">http://blackman.wp-club.net/</a></p>
</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
