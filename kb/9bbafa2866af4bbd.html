<html>
<head>
  <title>Управляющий протокол SNMP</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Управляющий протокол SNMP</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->
<p>Управляющий протокол SNMP</p>
Internet - гигантская сеть. Напрашивается вопрос, как она сохраняет свою целостность и функциональность без единого управления? Если учесть разнородность ЭВМ, маршрутизаторов и программного обеспечения, используемых в сети, само существование Internet представится просто чудом. Так все же как решаются проблемы управления в Internet? Отчасти на этот вопрос уже дан ответ - сеть сохраняет работоспособность благодаря жесткой протокольной регламентации.</p>
"Запас прочности" заложен в самих протоколах. Функции диагностики возложены, на протокол ICMP. Учитывая важность функции управления, для этих целей создано два протокола SNMP ( Simple Network Management Protocol - 1988г. ) и CMOT ( Common Management Information Services and Protocol over TCP/IP). Чаще всего управляющая прикладная программа воздействует на сеть по цепочке SNMP-UDP-IP-физическая_сеть. Наиболее важным объектом управления обычно является внешний порт сети или маршрутизатор. Каждому управляемому объекту присваивается уникальный идентификатор.</p>
Протокол SNMP работает на базе протокола UDP и предназначен для использования сетевыми управляющими станциями. Он позволяет управляющим станциям собирать информацию о положении в сети Internet. Протокол определяет формат данных, их обработка и интерпретация остаются на усмотрение управляющих станций или менеджера сети. SNMP-сообщения не имеют фиксированного формата и фиксированных полей. При работе протокол SNMP использует управляющую базу данных (MIB &#8212; Management Information Base, RFC-1213,-1212).</p>
Алгоритмы управления в Internet обычно описывают в нотации ASN.1 (Abstract Syntax Notation). Все объекты в Internet разделены на 10 групп и описаны в MIB: система, интерфейсы, обмены, трансляция адресов, IP, ICMP, TCP, UDP, EGP, SNMP. В группу "система" входит название и версия оборудования, операционной системы, сетевого программного обеспечения и пр. В группу "интерфейсы" входит число поддерживаемых интерфейсов, тип интерфейса, работающего под управлением IP (Ethernet, LAPB и т.д.), размер дейтограмм, скорость обмена, адрес интерфейса. IP-группа включает время жизни дейтограмм, информацию о фрагментации, маски субсетей и т.д. В TCP-группу входит алгоритм повторной пересылки, максимальное число повторных пересылок и пр. Команды SNMP приведены в табл. 1.15. В таблице PDU (Protocol Data Unit) - это тип протокольного сообщения. Взаимодействие источника SNMP-запросов с объектом управления показано на рис. 1.37.</p>
Таблица 1.15.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Команда SNMP</p>
</td>
<td >Тип PDU</p>
</td>
<td >Назначение</p>
</td>
</tr>
<tr >
<td >get_request</p>
</td>
<td >0</p>
</td>
<td >Получить значение указанной переменной или информацию о состоянии сетевого элемента</p>
</td>
</tr>
<tr >
<td >get_next_request</p>
</td>
<td >1</p>
</td>
<td >Получить значение переменной, не зная точного ее имени (следующий логический идентификатор на дереве MIB)</p>
</td>
</tr>
<tr >
<td >set_request</p>
</td>
<td >2</p>
</td>
<td >Присвоить переменной соответствующее значения. Используется для описания действие, которое должно быть выполнено</p>
</td>
</tr>
<tr >
<td >get response</p>
</td>
<td >3</p>
</td>
<td >Отклик на get_request, get_next_request и set_request, Содержит также информацию о состоянии (коды ошибок и другие данные)</p>
</td>
</tr>
<tr >
<td >trap</p>
</td>
<td >4</p>
</td>
<td >Отклик сетевого объекта на событие или на изменение состояния
</td>
</tr>
</table>
&nbsp;</p>
&nbsp;</p>
&nbsp;</p>
Рис. 1.38. Формат SNMP-сообщений, вкладываемых в UDP-дейтограммы</p>
Поле Версия содержит значение, равное номеру версии SNMP минус один. Поле Пароль (community - определяет группу доступа) содержит последовательность символов, которая является пропуском при взаимодействии менеджера и объекта управления. Обычно это поле содержит 6-байтовую строку public. Для запросов get, get-next и set значение поля Идентификатора запроса устанавливается менеджером и возвращается объектом управления в отклике get, что позволяет связывать в пары запросы и отклики. Поле Фирма (enterprise) = sysObjectlD объекта. Поле Статус ошибки характеризуется целым числом, присланным объектом управления (табл.1.16). </p>
В последнее время широкое распространение получила идеология распределенного протокольного интерфейса DPI (Distributed Protocol Interface). Для транспортировки SNMP-запросов используется не только UDP-, но и TCP-протокол. Это дает возможность применять SNMP-протокол не только в локальных сетях. Форматы SNMP-DPI-запросов (версия 2.0) описаны в документе RFC-1592. Пример заголовка SNMP-запроса (изображенные поля образуют единый массив):Поле Флаг = 0х30 является признаком ASN.1-заголовка. Коды Ln представляют собой длины полей, начинающиеся с байта, который следует за кодом длины, вплоть до конца сообщения-запроса (n &#8212; номер поля длины), если не оговорено другое. Так, L1 - длина пакета-запроса от Т1 до конца пакета, a L3 &#8212; длина поля пароля. Субполя Tn &#8212; поля типа следующего за ними субполя запроса. Так, Т1=2 означает, что поле характеризуется целым числом, а Т2=4 указывает на то, что далее следует пароль (поле community, в приведенном примере Public). Цифры под рамками означают типовые значения субполей. Код ОхА является признаком GET-запроса, за ним следует поле кода PDU (=0...4, см. табл. 1.15). Блок субполей Идентификатора запроса служит для тех же целей, что и другие идентификаторы, &#8212; для определения пары запрос-отклик. Собственно идентификатор запроса может занимать один или два байта, что определяется значением Lиз. CO &#8212; статус ошибки (СО=0 - ошибки нет); ТМ &#8212; тип MIB-переменной (в приведенном примере Ох2В); ИО &#8212; индекс ошибки. Цифровой код MIB-переменной отображается последовательностью цифровых субполей, характеризующих переменную. Например, переменная 1.3.6.1.2.1.5 (в символьном выражении iso.org.dod.internet.mgmt.mib.icmp) соответствует последовательности кодов Ох2В 0х06 0х01 0х02 0х01 0х05 0х00.</p>
Таблица 1.16.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td colspan="2" >Статус ошибки</p>
</td>
<td colspan="2" >Имя ошибки</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td colspan="2" >0</p>
1</p>
2</p>
</td>
<td colspan="2" >noError </p>
tooBig</p>
noSuchName</p>
</td>
<td >Все в порядке</p>
Объект не может уложить отклик в одно сообщение </p>
В операции указана неизвестная переменная</p>
</td>
</tr>
<tr >
<td colspan="2" >3</p>
4</p>
5</p>
</td>
<td colspan="2" >badValue</p>
readOnly</p>
genErr</p>
</td>
<td >в команде set использована недопустимая величина или неправильный синтаксис</p>
менеджер попытался изменить константу</p>
Прочие ошибки
</td>
</tr>
</table>
Если произошла ошибка, поле Индекс ошибки характеризует к какой из переменных это относится; индекс ошибки является указателем переменной и устанавливается объектом управления не равным нулю для ошибок badValue. Для команды trap (тип PDU-4 в табл. 1.15) формат сообщения меняется (рис. 1.38). Значения поля Тип trap приведены в табл. 1.17.</p>
Таблица 1.17.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Тип trap</p>
</td>
<td >Имя trap</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >0</p>
</td>
<td >coldStart</p>
</td>
<td >Установление начального состояния объекта</p>
</td>
</tr>
<tr >
<td >1</p>
</td>
<td >wannStart</p>
</td>
<td >Восстановление начального состояния объекта</p>
</td>
</tr>
<tr >
<td >2</p>
</td>
<td >linkDown</p>
</td>
<td >Интерфейс выключился. Первая переменная в сообщении идентифицирует интерфейс</p>
</td>
</tr>
<tr >
<td >3</p>
</td>
<td >linkUp</p>
</td>
<td >Интерфейс включился. Первая переменная в сообщении идентифицирует интерфейс</p>
</td>
</tr>
<tr >
<td >4</p>
</td>
<td >authenticationFailure</p>
</td>
<td >От менеджера получено SNMP-сообщение с Неверным паролем (community)</p>
</td>
</tr>
<tr >
<td >5</p>
</td>
<td >egpNeighborLoss</p>
</td>
<td >EGP-партнер отключился. Первая переменная в сообщении определяет IP-адрес партнера</p>
</td>
</tr>
<tr >
<td >6</p>
</td>
<td >entrpriseSpeclfic</p>
</td>
<td >Информация о trap содержится в поле Специальный код
</td>
</tr>
</table>
Для поля Тип trap 0&#8230;4 поле Специальный код должно быть равно нулю. Поле Временная метка содержит число сотых долей секунды (число тиков) с момента инициации объекта управления. Так, прерывание coldStart выдается объектом через 200 мс после инициализации.</p>
Протокол SNMP служит примером системы управления, в которой для достижения нужного результата не выдается команда, а осуществляется обмен информацией, решение принимается "на месте" в соответствии с полученными данными.</p>
Управляющая база данных MIB</p>
Вся управляющая информация для контроля ЭВМ и маршрутизаторов Internet концентрируются в базе данных MIB (Management Information Base, RFC-1213). Именно эти данные используются протоколом SNMP. MIB определяет, например, что программное обеспечение IP должно хранить число всех октетов, которые приняты любым из сетевых интерфейсов, управляющие программы могут только читать эту информацию.</p>
Согласно нормативам MIB управляющая информация делится на 8 категорий (табл. 1.18;см. также рис. 1.39).</p>
Таблица 1.18.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >MIB-категория</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >System</p>
Interfaces</p>
Addr. trans.</p>
Ip</p>
Icmp</p>
Tcp</p>
Udp</p>
egp</p>
</td>
<td >Операционная система ЭВМ или маршрутизация</p>
Сетевой интерфейс</p>
Преобразование адреса (напр., с помощью ARP)</p>
Программная поддержка протоколов Internet</p>
Программное обеспечение протокола ICMP</p>
Программное обеспечение протокола TCP</p>
Программное обеспечение протокола UDP</p>
Программное обеспечение протокола EGP
</td>
</tr>
</table>
В табл. 1.19 - 1.24 представлены наиболее важные объекты базы данных MIB, перечисленные в табл. 1.18.</p>
Помимо простых переменных объектами MIB могут быть таблицы. Для каждой таблицы имеется один или несколько индексов.</p>
Таблица 1.19.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Системная переменная</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >SysDescr</p>
SysObjectID</p>
SysUpTime</p>
SysContact</p>
SysName</p>
SysLocation</p>
sysService</p>
</td>
<td >Текстовое описание объекта</p>
Идентификатор производителя в рамках дерева (1.3.6.1.4.1)</p>
Время с момента последней загрузки системы (TimeTicks)</p>
Имя системного менеджера и способы связи с ним</p>
Полное имя домена</p>
Физическое местоположение системы</p>
Величина, характеризует услуги, предоставляемые узлом (сумма номеров уровней модели OSI)
</td>
</tr>
</table>
Таблица 1.20.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Переменная описания интерфейсов (ifTable)</p>
</td>
<td >Тип данных</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >IfIndex</p>
</td>
<td >INTEGER</p>
</td>
<td >Список интерфейсов от 1 до ifNumber</p>
</td>
</tr>
<tr >
<td >IfDescr</p>
</td>
<td >DisplayString</p>
</td>
<td >Текстовое описание интерфейса</p>
</td>
</tr>
<tr >
<td >IfType</p>
</td>
<td >INTEGER</p>
</td>
<td >Тип интерфейса, например, 6 - Ethernet; 9 - 802.5 маркерное кольцо; 23 - PPP; 28 - SLIP</p>
</td>
</tr>
<tr >
<td >IfNumber</p>
</td>
<td >INTEGER</p>
</td>
<td >Число сетевых интерфейсов</p>
</td>
</tr>
<tr >
<td >IfMtu</p>
</td>
<td >INTEGER</p>
</td>
<td >MTU для конкретного интерфейса</p>
</td>
</tr>
<tr >
<td >IfSpeed</p>
</td>
<td >Gauge</p>
</td>
<td >Скорость (бит/с)</p>
</td>
</tr>
<tr >
<td >IfPhysAddress</p>
</td>
<td >PhysAddress</p>
</td>
<td >Физический адрес или строка нулевой длины для интерфейсов без физического адреса (например, последовательный)</p>
</td>
</tr>
<tr >
<td >IfAdminStatus</p>
</td>
<td >[1&#8230;3]</p>
</td>
<td >Требуемое состояние интерфейса: 1 - включен; 2 - выключен; 3 - тестируется</p>
</td>
</tr>
<tr >
<td >IfOperStatus</p>
</td>
<td >[1&#8230;3]</p>
</td>
<td >Текущее состояние интерфейса: 1, 2, 3</p>
</td>
</tr>
<tr >
<td >IfLastChange</p>
</td>
<td >TimeTicks</p>
</td>
<td >SysUpTime, когда интерфейс оказался в данном состоянии</p>
</td>
</tr>
<tr >
<td >ifInOctets</p>
</td>
<td >Counter</p>
</td>
<td >Полное число полученных байтов</p>
</td>
</tr>
<tr >
<td >ifInUcastPkts</p>
</td>
<td >Counter</p>
</td>
<td >Число пакетов, доставленных на верхний системный уровень (unicast)</p>
</td>
</tr>
<tr >
<td >ifInDiscads</p>
</td>
<td >Counter</p>
</td>
<td >Число полученных, но отвергнутых пакетов</p>
</td>
</tr>
<tr >
<td >ifInErrors</p>
</td>
<td >Counter</p>
</td>
<td >Число пакетов, полученных с ошибкой</p>
</td>
</tr>
<tr >
<td >ifOutOctets</p>
</td>
<td >Counter</p>
</td>
<td >Число отправленных байтов</p>
</td>
</tr>
<tr >
<td >ifOutUcastPkts</p>
</td>
<td >Counter</p>
</td>
<td >Число unicast-пакетов, полученных с верхнего системного уровня</p>
</td>
</tr>
<tr >
<td >ifOutNUcastPkts</p>
</td>
<td >Counter</p>
</td>
<td >Число мультикастинг- и широковещательных пакетов, полученных с верхнего системного уровня</p>
</td>
</tr>
<tr >
<td >ifOutDiscads</p>
</td>
<td >Counter</p>
</td>
<td >Количество отвергнутых пакетов из числа отправленных</p>
</td>
</tr>
<tr >
<td >ifOutErrors</p>
</td>
<td >Counter</p>
</td>
<td >Число отправленных пакетов, содержащих ошибки</p>
</td>
</tr>
<tr >
<td >ifOutQLen</p>
</td>
<td >Gauge</p>
</td>
<td >Число пакетов в очереди на отправку
</td>
</tr>
</table>
Таблица 1.21.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Переменная</p>
ip-группы</p>
</td>
<td >Тип данных</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >ipDefaultTTL</p>
</td>
<td >INTEGER</p>
</td>
<td >Значение, которое используется IP в поле TTL</p>
</td>
</tr>
<tr >
<td >ipForwarding</p>
</td>
<td >[1&#8230;2]</p>
</td>
<td >1 означает, что система переадресует дейтограммы (2 - нет)</p>
</td>
</tr>
<tr >
<td >ipInReceives</p>
</td>
<td >Counter</p>
</td>
<td >Число полученных дейтограмм</p>
</td>
</tr>
<tr >
<td >ipForwDatagrams</p>
</td>
<td >Counter</p>
</td>
<td >Число переадресованных дейтограмм</p>
</td>
</tr>
<tr >
<td >ipOutNoRoutes</p>
</td>
<td >Counter</p>
</td>
<td >Число неудач при маршрутизации</p>
</td>
</tr>
<tr >
<td >ipFragOKs</p>
</td>
<td >Counter</p>
</td>
<td >Число фрагментированных IP-дейтограмм</p>
</td>
</tr>
<tr >
<td >ipRoutingTable</p>
</td>
<td >
</td>
<td >Таблица IP маршрутов</p>
</td>
</tr>
<tr >
<td >ipInHdrErrors</p>
</td>
<td >Counter</p>
</td>
<td >Число IP-дейтограмм, отвергнутых из-за ошибки в заголовке</p>
</td>
</tr>
<tr >
<td >ipInAddrErrors</p>
</td>
<td >Counter</p>
</td>
<td >Число IP-дейтограмм, отвергнутых из-за неверного адреса места назначения</p>
</td>
</tr>
<tr >
<td >ipInUnknownProtos</p>
</td>
<td >Counter</p>
</td>
<td >Число локально адресованных дейтограмм с неверным кодом протокола</p>
</td>
</tr>
<tr >
<td >ipInDiscards</p>
</td>
<td >Counter</p>
</td>
<td >Число дейтограмм, отвергнутых из-за нехватки места в буфере</p>
</td>
</tr>
<tr >
<td >ipInDelivers</p>
</td>
<td >Counter</p>
</td>
<td >Число доставленных дейтограмм</p>
</td>
</tr>
<tr >
<td >ipOutRequests</p>
</td>
<td >Counter</p>
</td>
<td >Полное число IP-дейтограмм, поступивших для пересылки без учета переадресованных</p>
</td>
</tr>
<tr >
<td >ipOutDiscards</p>
</td>
<td >Counter</p>
</td>
<td >Число отправляемых дейтограмм, потерянных из-за нехватки места в буфере</p>
</td>
</tr>
<tr >
<td >ipOutNoRoutes</p>
</td>
<td >Counter</p>
</td>
<td >Число потерянных IP-дейтограмм из-за отсутствия маршрута их доставки</p>
</td>
</tr>
<tr >
<td >ipReasmTimeout</p>
</td>
<td >Counter</p>
</td>
<td >Максимальное время (в секундах), которое IP-фрагмент может ждать сборки</p>
</td>
</tr>
<tr >
<td >ipReasmOKs</p>
</td>
<td >Counter</p>
</td>
<td >Число IP-дейтограмм, успешно прошедших сборку</p>
</td>
</tr>
<tr >
<td >ipReasmFails</p>
</td>
<td >Counter</p>
</td>
<td >Число случаев, когда алгоритм сборки не сработал</p>
</td>
</tr>
<tr >
<td >ipFragOKs</p>
</td>
<td >Counter</p>
</td>
<td >Число дейтограмм, успешно фрагментированных</p>
</td>
</tr>
<tr >
<td >ipFragFails</p>
</td>
<td >Counter</p>
</td>
<td >Число дейтограмм, которые нуждались в фрагментации, но не могли быть фрагментированы из-за того, что don't fragment_флаг=1</p>
</td>
</tr>
<tr >
<td >ipFragCreates</p>
</td>
<td >Counter</p>
</td>
<td >Число фрагментов, созданных в процессе фрагментации</p>
</td>
</tr>
<tr >
<td >ipRoutingDiscards</p>
</td>
<td >Counter</p>
</td>
<td >Число маршрутных записей, помеченных для ликвидации, хотя они и корректны</p>
</td>
</tr>
<tr >
<td colspan="3" >Таблица IP-адресов (ipAddrTable), индекс =&lt;ipAdEntAddr&gt;</p>
</td>
</tr>
<tr >
<td colspan="3" >IpAdEntAddr IpAddress IP-адрес для данного ряда</p>
IpAdEntIfIndex INTEGER Число интерфейсов</p>
IpAdEntNetMask IpAddress Маска субсети для данного IP-адреса</p>
IpAdEntBcastAddr [0&#8230;1] Значение младшего бита широковещательного адреса (обычно 1)</p>
IpAdEntReasmMaxSize [0&#8230;65535] Размер наибольшей IP-дейтограммы, полученной интерфейсом, которая может быть собрана
</td>
</tr>
</table>
Таблица 1.22.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Переменная</p>
tcp-группы</p>
</td>
<td >Тип данных</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >tcpRtoMin</p>
</td>
<td >INTEGER</p>
</td>
<td >Минимальное допустимое время повторной передачи TCP-пакетов</p>
</td>
</tr>
<tr >
<td >tcpRtoMax</p>
</td>
<td >INTEGER</p>
</td>
<td >Максимальное значение тайм-аута (в миллисекундах)</p>
</td>
</tr>
<tr >
<td >tcpMaxConn</p>
</td>
<td >INTEGER</p>
</td>
<td >Максимальное допустимое число TCP-соединений</p>
</td>
</tr>
<tr >
<td >tcpInSegs</p>
</td>
<td >Counter</p>
</td>
<td >Полное число полученных TCP-сегментов</p>
</td>
</tr>
<tr >
<td >tcpRtoAlgorithm</p>
</td>
<td >INTEGER</p>
</td>
<td >Алгоритм, используемый для вычисления тайм-аута: 1 - ни один из следующих; 2 - постоянное RTO; 3 - стандарт MIL-STD-1778; 4 - алгоритм Ван Джакобсона</p>
</td>
</tr>
<tr >
<td >tcpActiveOpens</p>
</td>
<td >Counter</p>
</td>
<td >Число переходов из состояния CLOSED в SYN_SENT</p>
</td>
</tr>
<tr >
<td >tcpPassiveOpens</p>
</td>
<td >Counter</p>
</td>
<td >Число переходов из состояния LISTEN в SYN_RCVD</p>
</td>
</tr>
<tr >
<td >tcpAttemptFails</p>
</td>
<td >Counter</p>
</td>
<td >Число переходов из состояния SYN_SENT или SYN_RCVD в CLOSED</p>
</td>
</tr>
<tr >
<td >tcpEstabResets</p>
</td>
<td >Counter</p>
</td>
<td >Число переходов из состояния ESTABLISHED или CLOSE_WAIT в CLOSED</p>
</td>
</tr>
<tr >
<td >tcpCurrEstab</p>
</td>
<td >Gauge</p>
</td>
<td >Число соединений, находящихся в состоянии ESTABLISHED или CLOSE_WAIT</p>
</td>
</tr>
<tr >
<td >tcpInSegs</p>
</td>
<td >Counter</p>
</td>
<td >Полное число полученных сегментов</p>
</td>
</tr>
<tr >
<td >tcpOutSegs</p>
</td>
<td >Counter</p>
</td>
<td >Полное число посланных сегментов, исключая повторно пересылаемые</p>
</td>
</tr>
<tr >
<td >tcpRetransSegs</p>
</td>
<td >Counter</p>
</td>
<td >Полное число повторно пересланных сегментов</p>
</td>
</tr>
<tr >
<td >tcpInErrs</p>
</td>
<td >Counter</p>
</td>
<td >Полное число сегментов, полученных с ошибкой</p>
</td>
</tr>
<tr >
<td >tcpOutRsts</p>
</td>
<td >Counter</p>
</td>
<td >Полное число посланных сегментов с флагом RST=1</p>
</td>
</tr>
<tr >
<td colspan="3" >tcpConnTable TCP-таблица связей</p>
</td>
</tr>
<tr >
<td colspan="3" >tcpConnState [1&#8230;12] Состояние соединения: 1 - CLOSED; 2 -LISTEN; 3 - SYN_SENT; 4 - SYN_RCVD; 5 - ESTABLISHED; 6 - FIN_WAIT_1; 7 - FIN_WAIT_2; 8 - CLOSE_WAIT; 9 - LAST_ACK; 10 - CLOSING; 11 - TIME_WAIT; 12 - delete TCB. Только последняя переменная может устанавливаться менеджером, прерывая связь</p>
tcpConnLocalAddress IpAddress Местный IP-адрес 0.0.0.0 означает, что приемник готов установить связь через любой из интерфейсов</p>
tcpConnLocalPort [0&#8230;65535] Местный номер порта</p>
tcpConnLocalAddress ipAddress Удаленный IP-адрес</p>
tcpConnRemPort [0&#8230;65535] Удаленный номер порта
</td>
</tr>
</table>
Таблица 1.23.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Переменная</p>
icmp-группы</p>
</td>
<td >Тип данных</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >icmpInEchos</p>
</td>
<td >Counter</p>
</td>
<td >Число полученных ICMP-запросов отклика</p>
</td>
</tr>
<tr >
<td >icmpInMsgs</p>
</td>
<td >Counter</p>
</td>
<td >Полное число полученных ICMP-сообщений</p>
</td>
</tr>
<tr >
<td >icmpInErrors</p>
</td>
<td >Counter</p>
</td>
<td >Число ICMP-сообщений, полученных с ошибками</p>
</td>
</tr>
<tr >
<td >icmpInDestUnreach</p>
</td>
<td >Counter</p>
</td>
<td >Число ICMP-сообщений о недостижимости адресата</p>
</td>
</tr>
<tr >
<td >icmpInTimeExcds</p>
</td>
<td >Counter</p>
</td>
<td >Число ICMP-сообщений об истечении времени</p>
</td>
</tr>
<tr >
<td >icmpInParmProbs</p>
</td>
<td >Counter</p>
</td>
<td >Число полученных ICMP-сообщений о проблемах с параметрами</p>
</td>
</tr>
<tr >
<td >icmpInSrcQuench</p>
</td>
<td >Counter</p>
</td>
<td >Число ICMP-сообщений с требованием сократить или прервать посылку пакетов из-за перегрузки</p>
</td>
</tr>
<tr >
<td >icmpInRedirects</p>
</td>
<td >Counter</p>
</td>
<td >Число ICMP-сообщений о переадресации</p>
</td>
</tr>
<tr >
<td >icmpInEchoReps</p>
</td>
<td >Counter</p>
</td>
<td >Число полученных ICMP-эхо-откликов</p>
</td>
</tr>
<tr >
<td >icmpInTimestamps</p>
</td>
<td >Counter</p>
</td>
<td >Число ICMP-запросов временных меток</p>
</td>
</tr>
<tr >
<td >icmpInAddrMasks</p>
</td>
<td >Counter</p>
</td>
<td >Число ICMP-запросов адресных масок</p>
</td>
</tr>
<tr >
<td >icmpOutMsgs</p>
</td>
<td >Counter</p>
</td>
<td >Число отправленных ICMP-сообщений</p>
</td>
</tr>
<tr >
<td >icmpOutErrors</p>
</td>
<td >Counter</p>
</td>
<td >Число неотправленных ICMP-сообщений из-за проблем (например, нехватка буферов)</p>
</td>
</tr>
<tr >
<td >icmpOutTimesExcds</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных ICMP-сообщений об истечении времени</p>
</td>
</tr>
<tr >
<td >icmpOutParmProbs</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных ICMP-сообщений о проблемах с параметрами</p>
</td>
</tr>
<tr >
<td >icmpOutQuench</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных ICMP-сообщений об уменьшении потока пакетов</p>
</td>
</tr>
<tr >
<td >icmpOutRedirects</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных ICMP-сообщений о переадресации</p>
</td>
</tr>
<tr >
<td >icmpOutEchos</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных ICMP-эхо-запросов</p>
</td>
</tr>
<tr >
<td >icmpOutEchoReps</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных ICMP-эхо-откликов</p>
</td>
</tr>
<tr >
<td >icmpOutTimestamps</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных ICMP-эхо-запросов временных меток</p>
</td>
</tr>
<tr >
<td >icmpOutAddrMasks</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных ICMP-эхо-запросов адресных масок
</td>
</tr>
</table>
Таблица 1.24.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Переменные at-группы (atTable)</p>
</td>
<td >Тип данных</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >atIfIndex</p>
</td>
<td >INTEGER</p>
</td>
<td >Число интерфейсов</p>
</td>
</tr>
<tr >
<td >atPhysAddress</p>
</td>
<td >PhysAddress</p>
</td>
<td >Физический адрес. Если эта переменная равна строке нулевой длины, физический адрес отсутствует</p>
</td>
</tr>
<tr >
<td >atNetAddress</p>
</td>
<td >NetworkAddress</p>
</td>
<td >IP-адрес
</td>
</tr>
</table>
Каждый протокол (например, IP) имеет свою таблицу преобразования адресов. Для IP это ipNetToMediaTable. Способ пропечатать таблицу преобразования с помощью программы snmpi описан ниже.</p>
В новейшей модификации управляющей базы данных (MIB II) содержатся объекты, принадлежащие к SNMP-группе. Эта группа предоставляет информацию о SNMP-объектах, информационных потоках, статистике ошибок (табл. 1.25).</p>
Таблица 1.25.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Название объекта</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >snmpInPkts</p>
</td>
<td >Число пакетов, полученных от слоя, расположенного ниже SNMP</p>
</td>
</tr>
<tr >
<td >snmpOutPkts</p>
</td>
<td >Число пакетов доставленных от SNMP к нижележащему слою</p>
</td>
</tr>
<tr >
<td >snmpInBadVersions</p>
</td>
<td >Индицирует число PDU, полученных с ошибкой в поле Версия (см. рис. 1.38)</p>
</td>
</tr>
<tr >
<td >snmpInBadCommunityNames</p>
</td>
<td >Индицирует число сообщений PDU, полученных с нечитаемым или нелегальным именем community</p>
</td>
</tr>
<tr >
<td >snmpInASNParsErrs</p>
</td>
<td >Указывает число PDU, которые не могут быть преобразованы в объекты ASN.1, и наоборот</p>
</td>
</tr>
<tr >
<td >snmpInBadTypes</p>
</td>
<td >Указывает число полученных PDU с недешифруемым типом</p>
</td>
</tr>
<tr >
<td >snmpInTooBigs</p>
</td>
<td >Указывает число полученных PDU со слишком большим значением поля Статус ошибки (см. рис. 1.38)</p>
</td>
</tr>
<tr >
<td >snmpInNoSuchNames</p>
</td>
<td >Указывает число PDU, полученных с индикацией ошибки в поле NoSuchName (см. табл. 1.16)</p>
</td>
</tr>
<tr >
<td >snmpInBadValues</p>
</td>
<td >Указывает число PDU, полученных с индикацией ошибки в поле BadValue (см. табл. 1.16)</p>
</td>
</tr>
<tr >
<td >snmpInReadOnlys</p>
</td>
<td >Указывает число PDU, полученных с индикацией ошибки в поле ReadOnly (см. табл. 1.16)</p>
</td>
</tr>
<tr >
<td >snmpInGenErrs</p>
</td>
<td >Указывает число PDU, полученных в GenErr-поле (см. табл. 1.16)</p>
</td>
</tr>
<tr >
<td >snmpInTotalReqVar</p>
</td>
<td >Указывает число объектов MIB, которые были восстановлены</p>
</td>
</tr>
<tr >
<td >snmpInTotalSetVars</p>
</td>
<td >Указывает число объектов MIB, которые были изменены</p>
</td>
</tr>
<tr >
<td >SnmpInGetRequests</p>
snmpInGetNexts</p>
snmpInSetRequests</p>
snmpInGetResposes</p>
snmpInTraps</p>
</td>
<td >Указывает число соответствующих PDU, которые были получены</p>
</td>
</tr>
<tr >
<td >snmpOutTooBig</p>
</td>
<td >Указывает число посланных PDU с полем TooBig</p>
</td>
</tr>
<tr >
<td >snmpOutNoSuchNames</p>
</td>
<td >Указывает число посланных PDU с полем NoSuchName</p>
</td>
</tr>
<tr >
<td >snmpOutBadValues</p>
</td>
<td >Указывает число посланных PDU с полем BadValue</p>
</td>
</tr>
<tr >
<td >snmpOutReadOnlys</p>
</td>
<td >Указывает число посланных PDU с полем ReadOnly</p>
</td>
</tr>
<tr >
<td >snmpOutGenErrs</p>
</td>
<td >Указывает число посланных PDU с полем GenErr</p>
</td>
</tr>
<tr >
<td >snmpEnableAuthTraps</p>
</td>
<td >Говорит о том, разрешены или нет ловушки (traps)</p>
</td>
</tr>
<tr >
<td >SnmpOutGetRequests</p>
snmpOutGetNexts</p>
snmpOutSetRequests</p>
snmpOutGetResposes</p>
snmpOutTraps</p>
</td>
<td >Указывает число соответствующих посланных PDU
</td>
</tr>
</table>
Стандарт на структуру управляющей информации (SMI) требует, чтобы все MIB-переменные были описаны и имели имена в соответствии с ASN.1 (Abstract Syntax Notation 1, формализованный синтаксис). ASN.1 является формальным языком, который обладает двумя основными чертами: нотация в документах легко читаема и понимаема; в компактном кодовом представлении информация может использоваться коммуникационными протоколами. В SMI присутствует неполный набор типов объектов, предусмотренный в ASN.1, разрешены только следующие типы примитивов: INTEGER, OCTET STRING, OBJECT IDENTIFIER и NULL. Практически в протоколе SNMP фигурируют следующие виды данных:</p>
INTEGER. Некоторые переменные объявляются целыми (INTEGER) с указанием начального значения или с заданным допустимымы диапазоном значений (в качестве примера можно привести номера UDP- или TCP-портов).</p>
OCTET STRING (последовательность байтов). В соответствии с требованиями BER (Basic Encoding Rules, ASN.1) последовательность октетов должна начинаться с числа байтов в этой последовательности (от 0 до N).</p>
OBJECT IDENTIFIER (идентификатор объекта). Имя объекта, представляющее собой последовательность целых чисел, разделенных точками. Например, 1.3.6.1.2.1.5.</p>
NULL. Указывает, что соответствующая переменная не имеет значения.</p>
DisplayString. Строка из 0 или более байтов (но не больше 255), которые являются ASCII-символами. Представляет собой частный случай OCTET STRING.</p>
PhysAddress. Последовательность октетов, характеризующая физический адрес объекта (6 байт для Ethernet). Частный случай OBJECT IDENTIFIER.</p>
Сетевой адрес. Допускается выбор семейства сетевых протоколов. В рамках ASN.1 этот тип описан как CHOICE, он позволяет выбрать протокол из семейства протоколов. В настоящее время идентифицировано только семейство протоколов Internet.</p>
IP-адрес. Этот адрес используется для определения 32-разрядного Интернет - адреса. В нотации ASN.1 - это OCTET STRING.</p>
Time Ticks (такты часов). Положительное целое число, которое используется для записи, например, времени последнего изменения параметров управляемого объекта, или времени последней актуализации базы данных (время измеряется в сотых долях секунды).</p>
Gauge (масштаб). Положительное целое число в диапазоне 0..232-1, которое может увеличиваться или уменьшаться. Если это число достигнет 232-1, то будет оставаться неизменным до тех пор, пока не будет обнулено командой сброс. Примером может служить переменная tcpCurrEsta, которая характеризует число TCP-соединений, находящихся в состоянии ESTABLISHED или CLOSE_WAIT.</p>
Counter (счетчик). Положительное число в диапазоне 0..232-1, которое может только увеличиваться, допуская переполнение.</p>
SEQUENCE. Этот объект аналогичен структуре в языке Си. Например, MIB определяет SEQUENCE с именем UdpEntry, содержащую информацию об активных UDP-узлах. В этой структуре содержится две записи:</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">1.</td><td>UdpLocalAddress типа IpAddress; местные IP-адреса; </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">1.</td><td>UdpLocalPort типа INTEGER; номера местных портов. </td></tr></table></div>SEQUENCE OF. Описание вектора, все элементы которого имеют один и тот же тип. Элементы могут представлять собой простые объекты, например, типа целое. В этом случае мы имеем одномерный список. Но элементами вектора могут быть объекты типа SEQUENCE, тогда этот вектор описывает двумерный массив.</p>
В MIB Internet каждый объект должен иметь имя (OBJECT IDENTIFIER), синтакс и метод кодировки.</p>
Стандарт ASN.1 определяет форму представления информации и имен. Имена MIB-переменных соответствуют в свою очередь стандартам ISO и CCITT. Структура имен носит иерархический характер, отображенный на рис. 1.39.</p>
В табл. 1.26 охарактеризованы четыре простые переменные, идентификаторы которых помещены в нижней части рис. 1.39. Все эти переменные допускают только чтение.</p>
В табл. 1.27 приведено описание таблицы udpTable (index=&lt;udpLocalAddress&gt;,&lt;udpLocalPort&gt;), состоящей из двух простых переменных, предназначенных только для чтения.</p>
Согласно иерархии рис. 1.39 переменные, соответствующие icmp, должны иметь префикс (идентификатор) 1.3.6.1.2.1.5 или в символьном выражении iso.org.dod.internet.mgmt.mib.icmp. Если вы хотите узнать значение какой-то переменной, следует послать запрос, содержащий соответствующие префикс и суффикс (последний определяет имя конкретной переменной). Для простой переменной суффикс имеет вид .0.</p>
<img src="pic/embim1784.png" width="402" height="318" vspace="1" hspace="1" border="0" alt=""></p>
Рис. 1.39. Структура идентификаторов переменных в MIB</p>
Таблица 1.26.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Имя Переменной</p>
</td>
<td >Тип данных</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >UdpInDatagrams</p>
</td>
<td >Counter</p>
</td>
<td >Число UDP-дейтограмм, присланных процессам пользователя</p>
</td>
</tr>
<tr >
<td >UdpNoPorts</p>
</td>
<td >Counter</p>
</td>
<td >Число полученных UDP-дейтограмм, для которых отсутствует прикладной процесс в порте назначения</p>
</td>
</tr>
<tr >
<td >UdpInErrors</p>
</td>
<td >Counter</p>
</td>
<td >Число не доставленных UDP-дейтограмм (например, ошибка контрольной суммы)</p>
</td>
</tr>
<tr >
<td >UdpDatagrams</p>
</td>
<td >Counter</p>
</td>
<td >Число посланных UDP-дейтограмм
</td>
</tr>
</table>
Таблица 1.27.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Имя переменной</p>
</td>
<td >Тип данных</p>
</td>
<td >Описание</p>
</td>
</tr>
<tr >
<td >UdpLocalAddress</p>
UdpLocalPort</p>
</td>
<td >IpAddress </p>
(0...65535)</p>
</td>
<td >Местный IP-адрес для данного приемника </p>
Местный номер порта приемника
</td>
</tr>
</table>
Лучшим способом закрепить в памяти все вышесказанное является использование программы snmpi (SNMP initiator или SNMPWALK, NETGUARD, SNMPMAN для PC). Если в вашем распоряжении имеется ЭВМ, работающая под управлением UNIX, например SUN, вы можете попутно узнать много полезного о вашей локальной сети. Синтаксис обращения к snmpi:</p>
snmpi [-a agent] [-с community] [-f file] [-p portno] [-d] [-v] [-w]</p>
Программа snmpi крайне проста. Для того чтобы проверить, работает ли онa, выдайте команду</p>
% snmpi dump</p>
Следует отметить, что в ответ на эту операций будет произведена весьма объемная выдача.</p>
Опция -a предлагает возможность ввести адрес SNMP-обьекта: имя ЭВМ, IP-адрес или транспортный адрес. По умолчанию это местная ЭВМ. Аналогично опция -р позволяет задать номер UDP-порта. По умолчанию это порт 61.</p>
Опция -с позволяет задать групповой пароль (community) для SNMP-запроса. По умолчанию это public, т.е. свободный доступ.</p>
Опция -f позволяет выбрать файл, содержащий откомпилированные описания MIB-модулей. По умолчанию это objects.defs.</p>
Опция -w включает режим наблюдения, осуществляя выдачу на терминал всех служебных сообщений. Уход из программы - по команде quit (q).</p>
Если вы работаете на IBM PC, и ваша машина подключена к локальной сети, получите допуск к одной из UNIX-машин в сети (если вы его не имели) и приступайте. Можно начать с обращения типа</p>
Snmpi -a 193.124.224.33</p>
(адрес или символьное имя надо взять из вашей локальной сети)</p>
Машина откликнется, отобразив на экране snmpi&gt;. Это означает, что программа имеется и вы можете вводить любые команды.</p>
Начать можно со знакомства с системными переменными системы (как и ранее курсивом выделены команды, введенные с клавиатуры).</p>
Snmpi&gt; get sysDescr.0</p>
Snmpi&gt; sysDescr.0="GS Software (GS3-K), Version 9.1(4) [fc1], SOFTWARE Copyright &#1111; 1986-1993 by Cisco Systems, Inc. Compiled Thu 25-Mar-93 09:49 by daveu"</p>
snmpi&gt; get sysObjectID.0</p>
snmpi&gt; sys0bjectlD.0=1.3.6.1.4.1.9.1.1</p>
snmpi&gt; get sysUpTime.0</p>
snmpi&gt; sysUpTime.0=14 days, 7 hours, 0 minutes, 15.27 seconds (123481527 timeticks)</p>
snmpi&gt; get sysServices.0</p>
snmpi&gt; sysServices.0=0x6&lt;datalink/subnetwork, internet&gt;</p>
Код 0x06 (sysServices.0) представляет собой сумму кодов уровней модели SO, поддерживаемых системой. Для справок: 0х01 - физический уровень; 0х02 связной уровень; 0х04 - Интернет; 0х08 - связь точка-точка; 0х40 - прикладной уровень.</p>
Если вы хотите получить информацию о состоянии интерфейсов на одной из ЭВМ, подключенных к вашей локальной сети (команды вызова snmpi далее не повторяются; в ниже приведенных примерах в круглых скобках помещены комментарии автора), выдайте команды:</p>
snmpi&gt; nextifTable</p>
(команда next в данном случае соответствует запросу get-next, здесь понятие "следующий" подразумевает порядок переменных в MlВ)</p>
snmpi&gt; iflndex.1=1</p>
snmpi&gt; get ifDescr.1</p>
snmpi&gt; ifDescr.1="Ethernet0"</p>
snmpi&gt; get ifType.1</p>
snmpi&gt; ifType.1=ethernet-csmacd (6)</p>
snmpi &gt; get ifMtu.1</p>
snmpi&gt; IfMtu.1=1500</p>
snmpi&gt; get ifSpeed.1</p>
snmpi&gt; ifSpeed.1=10000000 (10М бит/с, Ethernet)</p>
snmpi&gt; get ifPhysAddress.1</p>
snmpi&gt; ifPhysAddress.1=0х00:00:0c:02:За:49 (физический адрес интерфейса)</p>
snmpi&gt; next ifDescr.1 ifType.1 ifMtu.1 ifSpeed.1 ifPhysAddress.1</p>
snmpi&gt; ifDescr.2="Serial0"</p>
ifType.2=propPointToPointSerial(22)</p>
ifMtu.2=1500</p>
ifSpeed.2=2048000 (2 M бит/с, радиорелейный последовательный канал, спутниковый канал был бы охарактеризован точно также)</p>
В приведенном примере размеры пересылаемых блоков для Ethernet и радиорелейного последовательного канала идентичны и равны 1500 байт. Помните, что SLIP-канал записан как PointToPointSerial, а не как SLIP. Скорость обмена по SLIP-каналу не сообщается.</p>
Теперь просмотрим некоторые UDP-переменные. Например:</p>
snmpi&gt; next udp</p>
snmpi&gt; udpInDatagrams.0=98931</p>
snmpi&gt; next udpInDatagrams.0 (обратите внимание на суффикс простой переменной)</p>
snmpi&gt; udpNoPorts. 0=60009</p>
snmpi&gt; next udpLocalAddress.0</p>
snmpi&gt; udpLocalAddress.193.124.137.14.7=193.124.137.14 (Идентификатор этого объекта 1.3.6.1.2.1.7.5.1.1.193.124.137.14.7)</p>
snmpi&gt; next udpLocalPort</p>
snmpi&gt; udpLocalPort.193.124.137.14.7=7</p>
Если у вас возникла необходимость просмотреть таблицу, например, udpTable, это также можно сделать, используя snmpi:</p>
snmpi&gt; next udpTable</p>
snmpi&gt; udpLocalAddress.193.124.137.14.7=193.124.137.14</p>
snmpi&gt; next udpLocalAddress.193.124.137.14.7</p>
snmpi&gt; udpLocalAddress.193.124.224.33.67=193.124.224.33</p>
snmpi&gt; next udpLocalAddress.193.124.224.33.67</p>
snmpi&gt; udpLocalAddress.193.124.224.33.161=193.124.224.33</p>
snmpi&gt; next udpLocalPort.193.124.224.33.67</p>
snmpi&gt; udpLocalPort.193.124.224.33.161=161</p>
Ниже показана методика выяснения алгоритма и параметров задания значения тайм-аута:</p>
snmpi&gt; get tcpRtoAlgorithm.0 tcpRtoMin.0 tcpRtoMax.0 tcpMaxConn.0 </p>
snmpi&gt; tcpRtoAlgorithm.0=vanj(4) (vanj - алгоритм Ван Джакобсона для расчета времени тайм-аута)</p>
tcpRtoMin.0=300 (минимальное значение тайм-аута = 300 мс)</p>
tcpRtoMax.0=60000 (максимальное - 60 с)</p>
tcpMaxConn.0=-1 (никаких ограничений на число соединений)</p>
Чтобы получить информацию о состоянии таблицы адресных преобразований, выдайте команду snmpi -а 193.124.224.33 dump at (процедуры с использование субкоманды dump требуют некоторого времени для своего исполнения). В результате получим:</p>
AtIfIndex.1.1.193.124.224.33=1</p>
AtIfIndex.1.1.193.124.224.35=1</p>
AtIfIndex.3.1.192.148.166.203=3</p>
AtIfIndex.3.1.192.148.166.205=3</p>
AtIfIndex.5.1.145.249.30.33=5</p>
AtIfIndex.5.1.192.148.166.98=5</p>
AtPhysAddress.1.1.193.124.224.33=0x00:00:0c:02:3a:49</p>
AtPhysAddress.1.1.193.124.224.35=0x00:00:20:12:1b:b1</p>
AtPhysAddress.1.1.193.124.224.40=0x00:00:cd:f9:0d:e7</p>
AtPhysAddress.1.1.193.124.224.50=0x00:00:0c:02:fb:c5</p>
AtNetAddress.1.1.193.124.224.33=193.124.224.33</p>
AtNetAddress.1.1.193.124.224.35=193.124.224.35</p>
AtNetAddress.1.1.193.124.224.40=193.124.224.40</p>
AtNetAddress.1.1.193.124.224.50=193.124.224.50</p>
AtNetAddress.1.1.193.124.224.60=193.124.224.60</p>
(текст выдачи сокращен)</p>
Обычно элементы таблицы расположены в порядке колонка-ряд. Если вы дошли до края колонки или всей таблицы, ЭВМ выдаст (в зависимости от реализации программы) имя и значение следующего элемента или сообщение об ошибке.</p>
Чтобы получить полный текст адресной таблицы в рамках snmpi достаточно выдать команду</p>
Snmpi&gt; dump ipAddrTable</p>
Snmpi&gt; ipAdEntAddr.192.148.166.222=192.148.166.222</p>
IpAdEntAddr.192.168.1.1=192.168.1.1</p>
IpAdEntAddr.192.168.1.2=192.168.1.2</p>
IpAdEntAddr.193.124.224.33=193.124.224.33</p>
IpAdEntAddr.193.124.224.190=193.124.224.190</p>
IpAdEntIfIndex.192.148.166.222=3</p>
IpAdEntIfIndex.192.148.1.1=4</p>
IpAdEntIfIndex.192.148.1.2=6</p>
IpAdEntIfIndex.192.148.224.33=1</p>
IpAdEntIfIndex.192.148.224.190=5</p>
(маски субсетей)</p>
IpAdEntNetMask.192.148.166.222=255.255.255.224</p>
IpAdEntNetMask.192.148.1.1=255.255.255.0</p>
IpAdEntNetMask.192.148.1.2=255.255.255.0</p>
IpAdEntNetMask.192.148.224.33=255.255.255.224</p>
IpAdEntNetMask.192.148.224.190=255.255.255.224</p>
IpAdEntBcastAddr.192.148.166.222=1 (все эти субсети используют для широковещательной адресации одни и те же биты).</p>
IpAdEntBcastAddr.192.148.1.1=1</p>
IpAdEntBcastAddr.192.148.1.2=1</p>
IpAdEntBcastAddr.192.148.224.33=1</p>
IpAdEntBcastAddr.192.148.224.190=1</p>
IpAdEntReasmMaxSize.192.148.166.222=18024 (с точки зрения фрагментации и последующей сборки дейтограмм данные субсети эквивалентны).</p>
IpAdEntReasmMaxSize.192.148.1.1=18024</p>
IpAdEntReasmMaxSize.192.148.1.2=18024</p>
IpAdEntReasmMaxSize.192.148.224.33=18024</p>
IpAdEntReasmMaxSize.192.148.224.190=18024</p>
Эта распечатка совместно с приведенной для IfTable позволяет получить достаточно полную картину о данной конкретной локальной сети. Чтобы познакомиться с ARP таблицей, можно воспользоваться командой</p>
Sun&gt; arp -a</p>
Itepgw.itep.ru (193.124.224.33) at 0:0:c:2:3a:49</p>
Nb.itep.ru (193.124.224.60) at 0:80:ad:2:24:b7</p>
И дополнить полученные данные с помощью snmpi:</p>
Snmpi&gt; dump ipNetToMediaTable</p>
Snmpi&gt; ipNetToMediaIfIndex.1.193.124.224.33=1</p>
ipNetToMediaIfIndex.1.193.124.224.35=1</p>
ipNetToMediaIfIndex.3.192.148.166.193=3</p>
ipNetToMediaIfIndex.3.192.148.166.196=3</p>
ipNetToMediaIfIndex.3.193.124.226.110=3</p>
ipNetToMediaIfIndex.5.195.249.30.33=5</p>
ipNetToMediaIfIndex.5.192.148.166.100=5</p>
ipNetToMediaPhysAddress.1.193.124.224.33=0x00:00:0c:02:3a:49</p>
ipNetToMediaPhysAddress.3.192.148.166.196=0xaa:00:04:00:0c:04</p>
ipNetToMediaPhysAddress.3.192.148.166.198=0xaa:00:04:00:0e:04</p>
ipNetToMediaPhysAddress.3.192.148.166.203=0x00:00:01:00:54:62</p>
&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;</p>
ipNetToMediaPhysAddress.5.195.249.30.33=0x00:00:0c:02:69:7d</p>
IpNetToMediaPhysAddress.5.192.148.166.100=0x00: 20:af: 15:c1: 61</p>
IpNetToMediaPhysAddress.5.192.148.166.101=0x00:00:09:42:0d:e8</p>
IpNetToMediaNetAddress.1.193.124.224.33=193.124.224.33</p>
IpNetToMediaNetAddress.1.193.124.224.35=193.124.224.35</p>
IpNetToMediaNetAddress.3.192.148.166.193=192.148.166.193</p>
IpNetToMediaNetAddress.3.193.124.226.110=193.124.226.110</p>
IpNetToMediaNetAddress.5.195.249.30.33=195.249.30.33</p>
IpNetToMediaType.1.193.124.224.33=other(1)</p>
IpNetToMediaType.1.193.124.224.35=dynamic(3)</p>
IpNetToMediaType.1.193.124.224.37=dynamic(3)</p>
IpNetToMediaType.3.192.148.166.195=dynamic(3)</p>
IpNetToMediaType.3.192.148.166.222= other(1)</p>
IpNetToMediaType.5.193.124.224.190= other(1)</p>
IpNetToMediaType.5.193.124.225.33= other(1)</p>
IpNetToMediaType.5.193.124.225.35=dynamic(3)</p>
Синтаксис каждого объекта описывается в рамках ASN.1 и показывает побитовое представление объекта. Кодирование объекта характеризует то, как тип объекта отображается через его синтаксис и передается по телекоммуникационным каналам. Кодирование производится в соответствии с базовыми правилами кодирование ASN.1. Все описания объектов базируются на типовых шаблонах и кодах ASN.1 (см. RFC-1213). Формат шаблона:</p>
OBJECT (объект):</p>
Имя типа объекта с соответствующим ему идентификатором объекта</p>
(OBJECT IDENTIFIER)</p>
Syntax (синтаксис):</p>
ASN.1 описание синтаксиса типа объекта</p>
Definition (Определение)</p>
Текстовое описание типа объекта</p>
Access (доступ)</p>
Опции доступа</p>
Status (состояние)</p>
Статус типа объекта.</p>
Маршруты также являются объектами MIB. Согласно требованиям к MIB, каждому маршруту в этой базе соответствует запись, схема которой приведена на рис. 1.40.</p>
Поле Место назначения представляет собой IP-адрес конечной точки маршрута. Поле Индекс интерфейса определяет локальный интерфейс (физический порт), через который можно осуществить следующий шаг по маршруту. Следующие пять полей (Метрика 1&#8230;5) характеризует оценку маршрута. В простейшем случае, например для протокола RIP, достаточно было бы одного поля. Но для протокола OSPF необходимо пять полей (разные TOS). Поле Следующий шаг представляет собой IP-адрес следующего маршрутизатора. Поле Тип маршрута имеет значение 4 для опосредованного достижения цели маршрута; 2 для нереализуемого маршрута и 1 для случаев, отличных от вышеперечисленных.</p>
<table cellspacing="0" cellpadding="0" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr >
<td >Место назначения (ipRouteDept)</p>
</td>
</tr>
<tr >
<td >Индекс интерфейса (ipRouteIfIndex)</p>
</td>
</tr>
<tr >
<td >Метрика 1 (ipRouteMetric1)</p>
</td>
</tr>
<tr >
<td >&#8230;&#8230;.</p>
</td>
</tr>
<tr >
<td >Метрика 5 (ipRouteMetric5)</p>
</td>
</tr>
<tr >
<td >Следующий шаг (ipRouteNextHop)</p>
</td>
</tr>
<tr >
<td >Тип маршрута (ipRouteType)</p>
</td>
</tr>
<tr >
<td >Протокол маршрутизации (ipRouteProto)</p>
</td>
</tr>
<tr >
<td >Возраст маршрута (ipRouteAge)</p>
</td>
</tr>
<tr >
<td >Маска маршрута (ipRouteMask)</p>
</td>
</tr>
<tr >
<td >Маршрутная информация (ipRouteInfo)
</td>
</tr>
</table>
Рис. 1.40. Маршрутная таблица</p>
Поле Протокол маршрутизации содержит код протокола. Для RIP этот код равен 8, для OSPF -13, для BGP -14, для ICMP -4, для прочих протоколов -1. Поле Возраст маршрута описывает время (в секундах), прошедшее с момента последней коррекции маршрута. Следующее поле Маска маршрута используется для выполнения логической побитовой операции И над адресом в IP-дейтограмме перед сравнением результата с кодом, хранящимся в первом поле записи ("место назначения"). Последнее поле Маршрутная информация содержит код, зависящий от протокола маршрутизации и обеспечивающий ссылки на соответствующую информацию в базе MIB.</p>
</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
