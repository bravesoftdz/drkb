<html>
<head>
  <title>Типизированные файлы</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Типизированные файлы</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->

<p>Теперь разберем типизированные файлы. Типизированный файл - это файл в котором записанны идентичные структуры. Например любой файл можно считать файлом байтов - т.е. можно его читать байт за байтом, можно перейти сразу к любому байту по его номеру, можно сразу узнать сколько байт в файле, можно заменить любой байт на другой не перезаписывая файл. Теперь все это в примерах:</p>
<p>Объявляем файл байтов:</p>
<p>var f:file of byte;</p>
<p> &nbsp;&nbsp;&nbsp; b:Byte;</p>
<p>Ассоциируем файловую переменную с физическим файлом:</p>
<p>AssignFile(f,'c:\myfile.bin');</p>
<p>Теперь мы можем либо перезаписать/создать файл:</p>
<p>Rewrite(f);</p>
<p>Либо открыть существующий для чтения и записи:</p>
<p>Reset(f);</p>
<p>Обратите внимание, что функция Reset хотя и имеет такой же формат как и для текстовых файлов, но открытый ей файл можно и читать и писать, в отличие от текстовых.</p>
<p>Теперь функции работы с файлом:</p>
<p>read(f,b); - прочитать 1 байт </p>
<p>write(f,b); - записать 1 байт</p>
<p>seek(f,100); - поставить текущее положение считывания/записи на сотый байт</p>
<p>Size(f); - прочитать количество байт в файле. </p>
<p>Eof(f); - узнать не являетсмя ли байт последним</p>
<p>Все эти функции не работают с файлами большими 2 Gb.</p>
<p>После работы файл надо закрыть: </p>
<p>CloseFile(f);</p>
<p>Приведенные выше механизмы будут работать с любым файлом, так как любой файл можно считать файлом байтов. Теперь где это можно использовать? В принципе везде, но в подавляющем большинстве случаев это будет очень неудобно, ведь скорость считывания при чтении по байтам будет на порядки более низкой чем другими способами. Однако в некоторых случаях этот способ может быть очень полезен. Например в программе вам надо заменить 100й байт файла на другой, или прочитать 100й байт файла, например во всяких читерских программах, при взломе и т.п. Здесь такой доступ будет весьма удобен. Гораздо более интересным представляется дальнейшее развитие технологии типизированных файлов (их еще лет 15 назад называли "Файлы прямого доступа"). Представим себе, что файл состоит не из байт а из более сложных структур. Например мы имеем некоторую информацию в виде:</p>
<pre name="code" class="delphi">
Type MyRec=Record
           Name:string[100];
           Age:byte;
           Membership:Boolean;
           Accounts:array[1..10] of integer;
        End;
</pre>

<p>Обратите внимание, что все элементы записи точно типизированны, нет ни длинных строк, ни открытых массивов, ни объектов, другими словами, заранее точно известно сколько именно байт будет занимать переменная этого типа. Объявим переменную этого типа:</p>
<p>Var MyVar:MyRec;</p>
<p>и файл этого типа:</p>
<p>Var f:File of MyRec;</p>
<p>Теперь мы можем читать и писать сразу целую структуру, абсолютно так же как и если бы это был один байт:</p>
<pre name="code" class="delphi">
AssignFile(f,'c:\MyFile.rec');
Rewrite(f);
MyVar.Name:='Vitaly';
MyVar.Age:=33;
MyVar.Membership:=True;
MyVar.Accounts[1]:=12345;
MyVar.Accounts[2]:=34985;
Write(f,MyVar);
Closefile(f);
</pre>

<p>Все остальные функции приведенные в предыдущей статье будут работать так же, только одно отличие - Seek и Size оперируют не с количеством байт, а с количеством записей.</p>
</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
