<html>
<head>
  <title>RNA API</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">RNA API</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->

<p>Вот некоторые выдержки из сайта RNA API..<br>
&nbsp;<br>
//==================================================================//<br>
&nbsp;<br>
Здесь описаны некоторые недокументированные функции которые могут быть использованы для управления сервером удалённого доступа в системах Windows95/98.<br>
&nbsp;<br>
Когда я решил сделать прогу для управления dial-up сервером, я начал с того, что решил изучить, как работает родная виндовая панель управления сервером. Собственно диалог управления сервером (тот который вызывается из Dial-up networking ==&gt; Connections ==&gt; Dial-up server... либо щелчком по иконке в трее) находится в файле RNASERV.DLL. Как я быстро выяснил, в этом модуле по большому счёту ничего больше и нет, то есть это только контрольная панель, а собственно работа с сетью и модемами происходит где-то в другом месте. Для управления сервером RNASERV.DLL вызывает специальные функции из RASAPI32.dll, но не знакомые всем (и детально описанные в MSDN) функции RAS API (типа RasDial, имена их всех начинаются на &#171;Ras&#187;), а особые функции, имена которых начинаются на &#171;Rna&#187; и &#171;Suprv&#187;, о которых в MSDN ничего нет. Всё, что мне там удалось отыскать, это упоминание о неком RNA API, в Windows 95 DDK. (RNA расшифровывается как &#171;Remote Network Access&#187;) В DDK даже кратко описаны некоторые функции RNA API. Однако RNASERV.DLL всё равно использует совершенно другие RNA функции, о которых там нет ни слова.<br>
&nbsp;<br>
Пришлось рыть дальше. Поскольку я поставил себе достаточно конкретную задачу, написать приложение командной строки, заменяющее RNASERV.DLL, я не пытался разобраться во всём многообразье RNA API (в котором 61 функция), я изучил только самые необходимые функции, именно те, которые использует RNASERV.DLL. Далее приводится их описание.<br>
&nbsp;<br>
Функции RNA API: <br>
SuprvInitialize <br>
SuprvDeInitialize <br>
SuprvSetAccessInfo <br>
SuprvEnumAccessInfo <br>
SuprvGetAccessInfo <br>
RnaSMMInfoDialog <br>
SuprvRequest <br>
Структура: <br>
ACCESSINFO <br>
Структура ACCESSINFO<br>
struct ACCESSINFO {<br>
char m_szName[148]; <br>
unsigned int m_flags; // bit 0 - "allow caller access"<br>
unsigned int m_field_98;<br>
char m_szProtocol[4];<br>
unsigned int m_field_A0[11];<br>
char m_szComment[256];<br>
unsigned int m_field_1CC;<br>
unsigned short m_accessNumber; // 0 - share level access<br>
unsigned short m_field_1D2;<br>
unsigned short m_field_1D4;<br>
unsigned short m_field_1D6;<br>
unsigned short m_field_1D8;<br>
};<br>
&nbsp;<br>
Эта структура используется функциями SuprvSetAccessInfo и SuprvGetAccessInfo. К сожалению, смысл многих полей остался неясен. Не исключено, что часть из них просто зарезервированы, поскольку в большинстве случаев просто равны нулю. Вот что удалось выяснить:<br>
&nbsp;<br>
m_szName &#8211; название устройства (модема или COM/LPT порта)<br>
&nbsp;<br>
m_flags &#8211; самое интересное для нас поле. Если младший его бит равен 1, RNA сервер для данного устройства включён, 0 &#8212; выключен.<br>
&nbsp;<br>
m_szProtocol &#8211; чаще всего это поле просто забито нулями, но иногда в нём обнаруживается строчка "PPP", что наводит на мысль, что это поле означает используемый протокол соединения. Более точно, к сожалению, сказать не могу.<br>
&nbsp;<br>
m_szComment &#8211; комментарий. Тот самый, что можно ввести в диалоге Dial-Up Server, в поле Comment.<br>
&nbsp;<br>
m_accessNumber &#8211; как минимум означает тип контроля за разграничением доступа к серверу. Если равен 0 &#8212; значит используется &#8220;share level access control&#8221;. При этом проверяется только пароль. Если не равен нулю &#8212; значит производится проверка имени пользователя и пароля, то есть &#8220;user level access control&#8221;. Что конкретно при этом означает сама цифра, надо ещё разобраться, возможно число зарегистрированных пользователей. Похоже на то, что с управлением доступом связаны и другие поля структуры, но используются они только при &#8220;user level access control&#8221;. Поскольку для контроля за доступом на уровне пользователей необходимо наличие в сети NT сервера (который собственно и выполняет аутентификацию) мне не удалось поэкспериментировать с целью разобраться в смысле этих полей.<br>
&nbsp;<br>
Функции<br>
Все нижеперечисленные функции экспортируются из модуля RASAPI32.DLL. Их имнена не декорированы. Все они используют стандартное (или &#171;паскалевское&#187;) соглашение о вызовах.<br>
&nbsp;<br>
int __stdcall SuprvInitialize( HWND* _phWnd );<br>
Описание. Должна быть вызвана в первую очередь, перед тем, как вызывать какие-либо другие функции RNA API. Используется также для того, чтобы изменения конфигурации RNA сервера, внесённые с помощью SuprvSetAccessInfo немедленно вступили в силу.<br>
&nbsp;<br>
Параметры. Единственный параметр _phWnd указывает на дескриптор окошка, которое будет получать специальные сообщения о состоянии сервера.<br>
&nbsp;<br>
Возвращаемое значение. 0 &#8212; функция выполнена успешно. Не ноль &#8212; произошла ошибка.<br>
&nbsp;<br>
void __stdcall SuprvDeInitialize( void );<br>
Описание. Вызывается последней для завершения работы с RNA API. Каждому вызову SuprvInitialize должен соответствовать SuprvDeInitialize.<br>
&nbsp;<br>
Параметры. Нет.<br>
&nbsp;<br>
Возвращаемое значение. Нет.<br>
&nbsp;<br>
int __stdcall SuprvSetAccessInfo( ACCESSINFO* _pAccessInfoStruct );<br>
Описание. Самая интересная функция. Именно с помощью неё можно управлять сервером, в частности включить и выключить его. Состояние включён/выключен определяется младшим битом в поле m_flags структуры ACCESSINFO. RNASERV.DLL сразу после этой функции последовательно вызывает SuprvInitialize и SuprvDeInitialize. По-видимому, это требуется для того, чтобы внесённые изменения немедленно вступили в силу.<br>
&nbsp;<br>
Параметры. _pAccessInfoStruct указывает на структуру ACCESSINFO, для модема состояние которого надо изменить. Эту структуру лучше заполнить с помощью функции SuprvGetAccessInfo, а затем поменять в ней нужные параметры.<br>
&nbsp;<br>
Возвращаемое значение. ???<br>
&nbsp;<br>
void __stdcall SuprvEnumAccessInfo( char* _pStringsBuffer, int* _pStringsBufferSize, unsigned int* _pnStrings );<br>
Описание. Позволяет извлечь список устройств (модемов и COM/LPT портов).<br>
&nbsp;<br>
Параметры: <br>
&nbsp;<br>
_pStringsBuffer &#8211; указывает на буфер, куда должны быть помещены строки - названия устройств, разделённые нулевым символом. После последней строчки следуют два нулевых символа подряд. Этот параметр можно указать нулевым, что можно использовать для того, чтобы предварительно узнать требуемый размер буфера.<br>
&nbsp;<br>
_pStringsBufferSize &#8211; указывает на переменную, в которую помещается требуемый размер буффера. Если после вызова функции эта переменная оказалась &lt;=1, значит произошла ошибка.<br>
&nbsp;<br>
_pnStrings &#8211; указывает на переменную, в которую будет помещено число устройств.<br>
&nbsp;<br>
Возвращаемое значение. Нет.<br>
&nbsp;<br>
int __stdcall SuprvGetAccessInfo( char* _pAccessInfoString, ACCESSINFO* _pBuffer, unsigned int* _pnBufferSize );<br>
Описание. Извлекает всю информацию об устройстве. Заполняет структуру ACCESSINFO, которую потом можно использовать в функции SuprvSetAccessInfo.<br>
&nbsp;<br>
Параметры:<br>
&nbsp;<br>
_pAccessInfoString &#8211; указывает на имя устройства.<br>
&nbsp;<br>
_pBuffer &#8211; Указывает на структуру ACCESSINFO, которую надо заполнить. Перед вызовом в ней следует заполнить имя устройства. _pBuffer можно указать нулевым, что разумно использовать для того, чтобы предварительно узнать размер структуры. (По-видимому, он может быть переменным).<br>
&nbsp;<br>
_pnBufferSize &#8211; Указывает на переменную, в которую помещается размер структуры ACCESSINFO.<br>
&nbsp;<br>
Возвращаемое значение. Точно не известно, но по-видимому ноль означает успешное завершение функции.<br>
&nbsp;<br>
int __stdcall RnaSMMInfoDialog( HWND _hwnd, DWORD _dwUnused, ACCESSINFO* _pAccInfo, char* _pszProtocol );<br>
Описание. Вызывает диалог "Server Type"<br>
&nbsp;<br>
Параметры: <br>
&nbsp;<br>
_hwnd &#8211; дескриптор родительского окна.<br>
&nbsp;<br>
_dwUnused &#8211; должно быть нулём.<br>
&nbsp;<br>
_pAccInfo &#8211; указатель на сруктуру ACCESSINFO. (Быть может достаточно просто указателя на имя устройства.)<br>
&nbsp;<br>
_pszProtocol &#8211; на название протокола. RNASERV.DLL при вызове этой функции просто помещает в этот параметр указатель на поле m_szProtocol структуры ACCESSINFO.<br>
&nbsp;<br>
Возвращаемое значение. А хрен его знает :-) Похоже на индикатор успешного завершения или ошибки.<br>
&nbsp;<br>
void __stdcall SuprvRequest( int _command, void* _arg2, DWORD _arg3 );<br>
Описание. Весьма интересная функция. Судя по всему, многоцелевая. Однако я разобрался лишь с одной её возможностью: разорвать соединение с подключившимся компьютером. До остального прямо скажем руки не дошли.<br>
&nbsp;<br>
Параметры:<br>
&nbsp;<br>
_command &#8211; код команды. Код &#171;разорвать соединение&#187; &#8212; 0x38.<br>
&nbsp;<br>
_arg2 и _arg3 &#8211; назначение этих аргументов зависит от команды. Для команды "разорвать соединение" в качестве _arg2 следует передать указатель на структуру ACCESSINFO (быть может опять-таки достаточно только имени), а _arg3 должен быть нулём.<br>
&nbsp;<br>
<p>Возвращаемое значение. Отсутствует.</p>
&nbsp;<br>

</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
