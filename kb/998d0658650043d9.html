<html>
<head>
  <title>Delphi и Windows API (Статья)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Delphi и Windows API (Статья)</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->

<p>Одной из наиболее интересных особенностей Delphi является предоставление, наряду с высокоуровневыми функциями VCL, простого доступа к функциям Windows API. Программист в любой момент волен, в зависимости от стоящей перед ним задачи, выбрать для её решения простые в использовании компоненты, либо реализовать алгоритм, требующий компактности и быстродействия при помощи прямых вызовов API. Более того, как правило, можно не прекращая использовать компоненты и визуальное программирование нанести несколько штрихов при помощи API и добиться максимальной точности решения задачи и быстродействия.</p>

Windows &#8211; окна и сообщения</p>

Окна</p>
<p>Само название операционной системы Windows говорит, что основным её элементом является окно. Для успешного программирования разработчик должен четко представлять себе, что подразумевается в Windows под этим понятием. </p>
<p>Для начинающих программистов не очевидно, что окнами Windows являются не только главные окна, но и большинство элементов управления в них, таких как поля ввода, списки, кнопки и т.п. Фактически, любой элемент интерфейса, способный получать фокус ввода является окном Windows. Окна могут иметь окно-владельца (Parent window). В этом случае они называются дочерним окном (Child Window) и располагаются на поверхности владельца.</p>

Класс окна</p>
<p>Поведение окна и его внешний вид определяются классом окна. Класс &#8211; это внутренняя структура Windows, описывающая шаблон, на основании которого операционная система создает окна. Перед созданием окна Вы должны зарегистрировать его класс при помощи функции:</p>
<pre name="code" class="delphi">
function RegisterClassEx(
  const WndClass: TWndClassEx
): ATOM; stdcall;
</pre>

<p>Функция получает структуру данных TWndClassEx, описанную как:</p>
<pre name="code" class="delphi">
TWndClassEx = packed record
  cbSize: UINT;            // размер структуры, должен быть равен 
                           // SizeOf(TWndClassEx)
  style: UINT;             // стиль класса
  lpfnWndProc: TFNWndProc; // адрес процедуры-обработчика сообщений
  cbClsExtra: Integer;     // размер дополнительных данных класса
  cbWndExtra: Integer;     // размер дополнительных данных окна 
  hInstance: HINST;        // идентификатор модуля, в котором 
                           // находится процедура обработки сообщений
  hIcon: HICON;            // идентификатор значка окна
  hCursor: HCURSOR;        // курсор, который будет появляться при
                           // прохождении указателя мыши над окном
  hbrBackground: HBRUSH;   // кисть, используемая при заполнении фона 
                           // окна
  lpszMenuName: PAnsiChar; // имя ресурса, содержащего меню окна
  lpszClassName: PAnsiChar;// имя класса
  hIconSm: HICON;          // маленький значок окна
end;
</pre>


<p>Рассмотрим ключевые элементы этой структуры подробнее.</p>
Style &nbsp; &nbsp; &nbsp; &nbsp;Битовая маска, задающая стиль окна. Стиль &#8211; это набор флагов, указывающих системе, какие действия надо предпринимать «по умолчанию» при возникновении тех или иных событий в окне. Стиль класса в основном определяет моменты связанные с прорисовкой окна &nbsp; &nbsp; &nbsp; 
lpfnWndProc &nbsp; &nbsp; &nbsp; &nbsp;Адрес процедуры-обработчика сообщений. Каждый раз, когда в Windows возникает какое-либо событие, относящееся к окну (например, возникла необходимость в перерисовке или переместился курсор мыши над окном), система формирует сообщение, состоящее из идентификатора и двух целочисленных параметров wParam и lParam, и вызывает эту функцию. Таким образом, функция обработки сообщений и определяет поведение всех окон, созданных с этим стилем. &nbsp; &nbsp; &nbsp; 
hIcon &nbsp; &nbsp; &nbsp; &nbsp;Идентификатор значка, который будет выводиться в левом верхнем углу окна. Сам значок может быть загружен из ресурса функцией API LoadIcon. &nbsp; &nbsp; &nbsp; 
lpszMenuName  &nbsp; &nbsp; &nbsp; &nbsp;Имя меню. Это меню должно быть оформлено в виде ресурса. Если имя не задано &#8211; окно по умолчанию не будет иметь меню &nbsp; &nbsp; &nbsp; 
lpszClassName &nbsp; &nbsp; &nbsp; &nbsp;Имя класса. В дальнейшем на него можно будет ссылаться при создании новых окон. &nbsp; &nbsp; &nbsp; 
<p>Как видно из этой структуры именно на уровне класса окна определяется функция обработки сообщений, которая будет определять поведение всех окон с этим классом.</p>

<p>Создание окна</p>
<p>После того, как класс зарегистрирован, приложение может создавать окна этого класса функцией:</p>
<pre name="code" class="delphi">
function CreateWindowEx(
  dwExStyle: DWORD;    // расширенный стиль окна
  lpClassName: PChar;  // имя класса
  lpWindowName: PChar; // заголовок окна 
  dwStyle: DWORD;      // стиль окна
  X, Y, nWidth,        
  nHeight: Integer;    // размеры и позиция на экране
  hWndParent: HWND;    // идентификатор окна-владельца
  hMenu: HMENU;        // идентификатор меню окна
  hInstance: HINST;    // идентификатор модуля, ассоциированного с 
                       // окном
  lpParam: Pointer     // дополнительный параметр, передаваемый в 
                       // оконную процедуру с сообщением WM_CREATE
): HWND; stdcall;
</pre>


<p>Функция CreateWindowEx позволяет задать конкретный вид окна и уточнить информацию, полученную от класса окна.</p>

Сообщения</p>
<p>Сообщения &#8211; это базовый механизм информирования программ о событиях, на которые они должны реагировать. Ядром программы является функция обработки сообщений, зарегистрированная в классе окна, которая вызывается ядром Windows при появлении событий, на которые программа должна отреагировать. Получение сообщения окном означает вызов его оконной функции с параметрами, описывающими передаваемое сообщение. Например, сразу после создания окна оно получает сообщение WM_CREATE, при нажатии клавиш на клавиатуре &#8211; WM_KEYDOWN, WM_KEYUP, при перемещении мыши WM_MOUSEMOVE и т.п. Без обработки сообщений окно не сможет даже отрисовать себя &#8211; рисование выполняется по получению сообщений WM_PAINT, WM_NCPAINT. В программе, написанной с использованием только WinAPI, функция обработки сообщений обычно представляет собой оператор case, альтернативами которого являются различные сообщения, которые эта функция должна обработать.</p>

TWinControl &#8211; оболочка окна Windows</p>
<p>Программирование создания окон и цикла обработки сообщений вручную является непростой и довольно низкоуровневой задачей. VCL реализует классы, позволяющие избежать возникающих при этом сложностей. </p>
<p>Базовым классом, инкапсулирующим окно Windows, является TWinControl. При создании экземпляра наследника этого класса, VCL автоматически регистрирует соответствующий класс окна Windows и создает окно. Благодаря этому, наследники TWinControl могут содержать в себе другие окна и обрабатывать сообщения Windows. Визуальные компоненты, не являющиеся наследниками TWinControl (такие, как TLabel, TSpeedButton) не являются окнами в понимании Windows. Все их события эмулируются компонентом, в который они помещены.</p>
Свойство Handle</p>
<p>Центральным свойством компонента TWinControl является свойство Handle. Это свойство представляет идентификатор окна Windows, полученного при создании этого компонента. Этот идентификатор можно использовать с любыми функциями Windows API, работающими с окнами. Например, следующий код прокручивает текст в TMemo на одну строку вниз:</p>
<pre name="code" class="delphi">
procedure TForm1.Button1Click(Sender: TObject);
begin
  PostMessage(Memo1.Handle, WM_VSCROLL, SB_LINEDOWN, 0);
end;
</pre>


Метод CreateParams</p>
<p>Перед созданием окна TWinControl вызывает виртуальный метод CreateParams, позволяя программисту задать низкоуровневые параметры создаваемого окна. В процедуру передается структура данных</p>
<pre name="code" class="delphi">
TCreateParams = record
  Caption: PChar;     // Заголовок окна, соответствует параметру
                      // lpWindowName
  Style: Longint;     // Стиль окна, соответствует параметру dwStyle
  ExStyle: Longint;   // Расширенный стиль окна (dwExStyle)
  X, Y: Integer;  
  Width, Height: Integer; // Координаты окна
  WndParent: HWND;    // Идентификатор окна-владельца (hWndParent)
  Param: Pointer      // Дополнительный параметр (lpParam)
  WindowClass: TWndClass;  // Структура TWndClass, позволяющая задать
                           // параметры класса окна 
  WinClassName: array[0..63] of Char; // Имя класса окна 
                                      // (lpClassName)
end;
</pre>


<p>Наследники TWinControl могут перекрыть CreateParams, создавая окна с требуемыми внешним видом и поведением. Например, требуется создать форму, не имеющую заголовка, однако позволяющую изменять свои размеры. Delphi не предоставляет возможности задать такое поведение визуальными средствами, однако, перекрыв TForm.CreateParams мы легко добиваемся нужного эффекта:</p>
<pre name="code" class="delphi">
procedure TForm1.CreateParams(var Params: TCreateParams);
begin
  inherited; // Вызываем унаследованный обработчик, позволяя
             // VCL подготовить «типовую» конфигурацию окна
  with Params do
    // И изменяем требуемые параметры
    Style := Style and (not WS_CAPTION) or WS_THICKFRAME or WS_POPUP;
end;
</pre>


<p>В качестве упражнения рекомендую посмотреть на некоторые фрагменты реализации класса TWinControl, расположенного в модуле Controls.pas. Хорошо видно, что метод CreateWnd сначала вызывает метод CreateParams, заполняющий структуру WndClass с параметрами класса окна и параметры для CreateWindow, а затем регистрирует класс и создает окно. Также очень показателен метод TCustomForm.CreateParams, расположенный в модуле Forms.pas. Хорошо видно, как по свойствам Position, BorderIcons и FormStyle формируется набор флагов стиля окна для функции CreateWindow.</p>

Обработка сообщений</p>
<p>Каждое окно Windows должно обрабатывать сообщения. VCL берет на себя работу по организации цикла сообщений и их базовой обработке. Для большинства сообщений Windows, которые должно обрабатывать окно, уже предусмотрена обработка «по умолчанию». Сообщения, требующие специфической обработки, приводят к вызовам функций-обработчиков событий, например:</p>

WM_MOUSEMOVE &nbsp; &nbsp; &nbsp; &nbsp;OnMouseMove &nbsp; &nbsp; &nbsp; 
WM_LBUTTONDOWN, WM_RBUTTONDOWN &nbsp; &nbsp; &nbsp; &nbsp;OnMouseDown &nbsp; &nbsp; &nbsp; 
WM_LBUTTONUP, WM_RBUTTONUP &nbsp; &nbsp; &nbsp; &nbsp;OnMouseUp &nbsp; &nbsp; &nbsp; 
WM_LBUTTONDBLCLK &nbsp; &nbsp; &nbsp; &nbsp;OnDblClick &nbsp; &nbsp; &nbsp; 
WM_KEYDOWN &nbsp; &nbsp; &nbsp; &nbsp;OnKeyDown &nbsp; &nbsp; &nbsp; 
WM_KEYUP &nbsp; &nbsp; &nbsp; &nbsp;OnKeyUp &nbsp; &nbsp; &nbsp; 
WM_PAINT &nbsp; &nbsp; &nbsp; &nbsp;OnPaint &nbsp; &nbsp; &nbsp; 
<p>И так далее. Показателен в этом смысле метод WndProc класса TWinControl или его наследников. При этом VCL перед вызовом обработчиков производит «упаковку» параметров сообщений в удобный для обработки и анализа вид. Понимание, какое сообщение Windows вызывает срабатывание того или иного события VCL очень помогает при программировании обработчиков и совершенно необходимо при написании собственных компонентов. Разумеется, предусматривать отдельные обработчики для всех из сотен сообщений, которые могут поступить в окно &#8211; значит неоправданно усложнить код VCL. Поэтому для обработки остальных сообщений синтаксис Object Pascal предусматривает создание процедур-обработчиков сообщений. Такие процедуры объявляются как</p>

<p>procedure WMSize(var Message: TWMSize); message WM_SIZE;</p>

<p>В качестве параметра такая функция получает указатель на структуру TMessage, содержащую информацию о сообщении, переданном окну. Для многих часто используемых сообщений в модуле Messages.pas определены структуры, позволяющие более удобно работать с конкретными сообщениями. </p>
<p>Рассмотрим пример окна, обрабатывающего сообщение, не предусмотренное VCL. В качестве сообщения используем WM_HOTKEY. Это сообщение посылается окну, при нажатии зарегистрированной в Windows «горячей клавиши», что позволяет программе реагировать на эту клавишу, даже не имея фокуса ввода.</p>
<pre name="code" class="delphi">
type
  TForm1 = class(TForm)
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
  private
    // объявляем процедуру-обработчик
    procedure WMHotKey(var Msg: TWMHotKey); message WM_HOTKEY;
  end;
 
procedure TForm1.FormCreate(Sender: TObject);
begin
  // Регистрируем "горячую клавишу" Ctrl+Alt+F5
  RegisterHotKey(Handle, 0, MOD_CONTROL or MOD_ALT, VK_F5);
end;
 
procedure TForm1.WMHotKey(var Msg: TWMHotKey);
begin
  // Эта процедура вызывается при получении окном
  // сообщения WM_HOTKEY
  inherited;  // Даем форме обработать сообщение
              // если у неё уже есть его обработчик
  Beep;       // Выполняем дополнительные действия
end;
 
procedure TForm1.FormDestroy(Sender: TObject);
begin
  // Отменяем регистрацию "горячей клавиши"
  UnRegisterHotKey(Handle, 0);
end;
</pre>


<p>Обращаю внимание на вызов унаследованного обработчика в методе WMHotKey. Если Вы не уверены, что хотите запретить обработку предком подобного сообщения &#8211; всегда вызывайте унаследованный обработчик. В противном случае, Вы рискуете помешать VCL обрабатывать сообщения. Например, написав свой обработчик WM_PAINT и не вызвав в нем унаследованный Вы полностью заблокируете перерисовку формы средствами VCL.</p>

Свойства Controls и Parent</p>
<p>Каждый наследник TWinControl может служить контейнером для других компонентов. Для связи между родительским и дочерними компонентами служат свойства Controls и Parent. Каждый визуальный компонент имеет свойство Parent, ссылающееся на оконный компонент, являющийся его владельцем. До тех пор, пока не установлено это свойство, компонент не может обрабатывать сообщения Windows и отображаться на экране. Окно-предок ведет список вставленных в него компонентов, доступ к которому можно получить при помощи его свойства Controls.</p>

TForm &#8211; просто окно</p>
<p>Delphi вводит новую для Windows концепцию &#8211; форма. Такого понятия нет в Windows, однако оно довольно часто встречается в высокоуровневых средствах разработки. Форма инкапсулирует окно верхнего уровня (top-level window), которое служит контейнером для остальных визуальных элементов программы. С точки зрения Windows &#8211; это такое же окно, как и все остальные, только с соответствующим образом подобранным набором стилей. В частности, на этом уровне реализована поддержка главного меню, управление дочерними окнами (MDI). Как и любое окно TForm имеет свойство Handle, которое может быть использовано в вызовах Windows API. Например, следующий код создает форму в виде пятиконечной звезды:</p>
<pre name="code" class="delphi">
procedure TForm1.FormCreate(Sender: TObject);
const
  Points: packed array [1..10] of TPoint =
   ((X:50; Y:0), (X:63; Y:33), (X:100; Y:33), (X:72; Y:55),
    (X:90; Y:100), (X:50; Y:72), (X:10; Y:100), (X:28; Y:55),
    (X:0; Y:33), (X:37; Y:33));
begin
  BorderStyle := bsNone;
  Brush.Color := clRed;
  SetWindowRgn(Handle, CreatePolygonRgn(Points, 10, WINDING), TRUE);
end;
</pre>


<p>Концепция форм помогает разработчику в управлении окнами верхнего уровня, однако многие её понятия (например, главное окно приложения, список окон (Screen.Forms)) не имеет прямых аналогов в Windows API.</p>

Графика</p>
<p>Программы Windows не имеют возможности прямого вывода информации на экран. Вместо этого, программа, желающая что-либо нарисовать в своем окне должна вызвать одну из функций Windows API, предназначенных для рисования. Такой подход позволяет Windows обеспечить одновременную «жизнь» на одном экране нескольких программ, каждая из которых выводит в своем окне произвольную информацию. Вопросы отсечения информации невидимых участков окон и взаимодействия с конкретным драйвером графического устройства ложатся на операционную систему.</p>

Графическая подсистема Windows </p>
<p>Базовым понятием графической подсистемы Windows является контекст графического устройства &#8211; внутренняя структура, определяющая набор графических объектов, их атрибутов и графических режимов, которые могут повлиять на вывод информации. Контекст может быть связан с различными устройствами, такими, как дисплей, принтер, изображение в памяти, что позволяет использовать одни и те же функции для вывода информации на любое из этих устройств. Разумеется, при этом необходимо учитывать возможности конкретного устройства, такие как разрешение или поддерживаемый набор цветов.</p>
<p>Типичный сценарий вывода информации в Windows выглядит следующим образом:</p>
<p>Получить контекст устройства</p>
<p>  Сформировать графические объекты с требуемыми аттрибутами,</p>
<p> &nbsp;&nbsp; такие как шрифт, кисть</p>
<p>  «Включить» объекты в контекст, возможно сохранив при этом старые</p>
<p> &nbsp;&nbsp; объекты</p>
<p>  Установить аттрибуты контекста (режим заполнения и т.п.), сохранив</p>
<p> &nbsp;&nbsp; старые аттрибуты</p>
<p>  Используя функции рисования вывести информацию на устройство</p>
<p>  Восстановить аттрибуты контекста</p>
<p>  Восстановить графические объекты </p>
<p>  Освободить созданные временые графические объекты</p>
<p>Освободить контекст устройства</p>
<p>Хорошо видно, что собственно вывод информации занимает далеко не главную часть в общем объеме кода. Большая часть времени уходит на создание, сохранение и восстановление графических объектов. При этом нередки трудно находимые ошибки, приводящие к утечке ресурсов из за не освобожденных объектов.</p>

Класс TCanvas</p>
<p>VCL предлагает элегантное решение проблемы, описанной в предыдущем разделе &#8211; класс TCanvas, инкапсулирующий контекст графического устройства Windows. Вместе с вспомогательными классами TFont, TBrush и т.д., реализующими графические объекты этот класс берет на себя всю работу, связанную с получением и освобождением контекстов устройства его атрибутов и графических объектов. Когда Вы меняете, например, свойства кисти (Canvas.Bush) &#8211; TCanvas автоматически создаст новую кисть с нужными атрибутами и включит её в свой контекст, а старую &#8211; корректно удалит. Наряду с этим, TCanvas реализует ряд методов, позволяющих рисовать на нем без указания контекста устройства. В итоге &#8211; программист может вообще не знать ничего о том, как работает графическая подсистема Windows, используя только методы TCanvas. Все классы VCL, допускающие рисование имеют свойство Canvas, указывающее на автоматически создаваемый экземпляр TCanvas, связанный с ним</p>

Использование Windows API с TCanvas</p>
<p>Реализовать в TCanvas все функции рисования Windows нереально, т.к. это приведет к резкому усложнению кода VCL. Однако, TCanvas имеет свойство Handle, которое представляет идентификатор графического контекста Windows, ассоциированного с экземпляром класса. Используя его мы можем задействовать все многообразие функций API, предназначенных для рисования. При этом всю работу по установке атрибутов и недопущению утечки ресурсов можно оставить на реализацию TCanvas.</p>
<p>Рассмотрим наиболее употребимые функции Windows API, которые могут быть использованы для рисования.</p>
<p>DrawText</p>
<p>Функция DrawText объявлена как:</p>
<pre name="code" class="delphi">
function DrawText(
  hDC: HDC;          // Контекст графического устройства 
                     // (TCanvas.Handle)
  lpString: PChar;   // Строка для вывода на экран
  nCount: Integer;   // Количество символов в строке, если строка
                     // имеет нуль-терминатор – можно передать -1
  var lpRect: TRect; // Прямоугольник, в котором будет отрисована 
                     // строка
  uFormat: UINT      // Флаги форматирования.
): Integer; stdcall; // Функция возвращает высоту текста в пикселях
</pre>

<p>Эта функция имеет широкие возможности по форматированию текста, задаваемые параметром uFormat. Этот параметр представляет собой набор битовых флагов, задающих способ выравнивания и дополнительные операции над текстом.</p>
<p>Рассмотрим некоторые из этих флагов:</p>
DT_SINGLELINE &nbsp; &nbsp; &nbsp; &nbsp;Текст выводится в одну строку, игнорируя символы перевода строки и возврата каретки. С этим флагом могут комбинироваться DT_TOP, DT_BOTTOM и DT_VCENTER, задающие вертикальное выравнивание текста. &nbsp; &nbsp; &nbsp; 
DT_WORDBREAK  &nbsp; &nbsp; &nbsp; &nbsp;Текст разбивается на строки так, чтобы он поместился по ширине в прямоугольнике lpRect. Символы возврата каретки и перевода строки также приводят к переходу на новую строку. &nbsp; &nbsp; &nbsp; 
DT_LEFT DT_CENTER DT_RIGHT &nbsp; &nbsp; &nbsp; &nbsp;Выравнивает выводимый текст по левому краю, по центру или по правому краю. &nbsp; &nbsp; &nbsp; 
DT_END_ELLIPSIS &nbsp; &nbsp; &nbsp; &nbsp;Если строка не помещается в lpRect её конец заменяется на три точки. Бывает удобно использовать для вывода полей, имеющих значительную длину. &nbsp; &nbsp; &nbsp; 
DT_PATH_ELLIPSIS &nbsp; &nbsp; &nbsp; &nbsp;Используется с путями, содержащими символ '\'. Если строка не помещается в lpRect &#8211; часть её из середины заменяется на три точки. &nbsp; &nbsp; &nbsp; 
<p>Также, эта функция может использоваться для расчета высоты или ширины области, занимаемой текстом. Для этого, наряду с остальными флагами форматирования надо добавить флаг DT_CALCRECT. Если выводится одна строка текста, то DrawText изменяет lpRect.Right так, чтобы он вместил всю эту строку, если несколько строк (DT_WORDBREAK) &#8211; то изменяется lpRect.Bottom так, чтобы полученный прямоугольник вместил весь текст.</p>
<p>Рассмотрим в качестве примера создание списка, содержащего 2 колонки. Первая из них содержит номер позиции, вторая &#8211; сопроводительный текст, высота которого может изменяться. Для создания такого списка разместим на форме TListBox, установив его свойство Style в lbOwnerDrawVariable. После этого создадим следующие обработчики событий:</p>
<pre name="code" class="delphi">
procedure TForm1.FormCreate(Sender: TObject);
begin
  with ListBox1.Items do begin
    // Заполняем список
    Add('Первая позиция');
    Add('Вторая позиция. Её описание имеет значительную длину');
    Add('Третья позиция'#13'В ней'#13'имеются переводы строки');
    Add('Четвертая позиция');
  end;
end;
 
procedure TForm1.ListBox1MeasureItem(Control: TWinControl; 
  Index: Integer; var Height: Integer);
var
  R: TRect;
begin
  // Заполняем R, оставив 20 пикселов для первой колонки
  // и 4 пиксела для учета рамки компонента
  R := Rect(20, 0, ListBox1.Width-4, Height);
  // И вычисляем высоту прямоугольника, требуемую
  // для вывода всего текста
  Height := DrawText(ListBox1.Canvas.Handle,
    PChar(ListBox1.Items[Index]), -1, R, 
    DT_CALCRECT or DT_WORDBREAK);
end;
 
procedure TForm1.ListBox1DrawItem(Control: TWinControl; 
  Index: Integer; Rect: TRect; State: TOwnerDrawState);
begin
  with ListBox1 do begin
    // Очищаем зону рисования
    Canvas.FillRect(Rect);
    // Выводим номер позиции, центрируя его по вертикали
    DrawText(Canvas.Handle, PChar(IntToStr(Index + 1)), -1, Rect,
      DT_VCENTER or DT_SINGLELINE);
    // Получаем зону для вывода остального текста
    Inc(Rect.Left, 20);
    // И выводим его
    DrawText(Canvas.Handle, PChar(Items[Index]), -1, Rect, 
      DT_WORDBREAK);
  end;
end;
</pre>


<p>DrawEdge</p>
<p>Функция DrawEdge ,бывает очень полезна при написании собственных компонентов. Она автоматизирует задачу рисования трехмерных кнопок, рамок и т.п. Функция&nbsp; объявлена как:</p>
<pre name="code" class="delphi">
function DrawEdge(
  hdc: HDC;        // Графический контекст
  var qrc: TRect;  // Координаты рамки
  edge: UINT;      // Тип рамки
  grfFlags: UINT   // Тип бордюра
): BOOL; stdcall;  
</pre>


<p>Рамка рисуется в виде комбинации из двух прямоугольников &#8211; внутреннего (inner) и внешнего (outer). Каждый из них может быть выпуклым (raised), либо вдавленным (sunken). Тип рамки определяется параметром edge, который представляет собой битовую маску из следующих значений:</p>
BDR_RAISEDINNER&nbsp; BDR_SUNKENINNER  &nbsp; &nbsp; &nbsp; &nbsp;Задают выпуклый, либо вдавленный внутренний контур &nbsp; &nbsp; &nbsp; 
BDR_RAISEDOUTER BDR_SUNKENOUTER &nbsp; &nbsp; &nbsp; &nbsp;Задают выпуклый, либо вдавленный внешний контур &nbsp; &nbsp; &nbsp; 
<p>Также имеются предопределенные флаги</p>
EDGE_BUMP &#8211; выпуклая рамка</p>
EDGE_ETCHED - вдавленная рамка</p>
EDGE_RAISED &#8211; выпуклая кнопка </p>
EDGE_SUNKEN &#8211; вдавленная кнопка</p>
<p>Параметр grfFlags определяет тип бордюра. Это набор следующих флагов</p>
BF_BOTTOM BF_TOP BF_LEFT BF_RIGHT &nbsp; &nbsp; &nbsp; &nbsp;Рисуется соответствующая сторона рамки. &nbsp; &nbsp; &nbsp; 
BF_BOTTOMLEFT BF_BOTTOMRIGHT BF_TOPLEFT BF_TOPRIGHT &nbsp; &nbsp; &nbsp; &nbsp;Рисуется соответствующий угол &nbsp; &nbsp; &nbsp; 
BF_RECT &nbsp; &nbsp; &nbsp; &nbsp;Рисуется вся рамка &nbsp; &nbsp; &nbsp; 
BF_DIAGONAL BF_DIAGONAL_ENDBOTTOMLEFT BF_DIAGONAL_ENDBOTTOMRIGHT BF_DIAGONAL_ENDTOPLEFT BF_DIAGONAL_ENDTOPRIGHT &nbsp; &nbsp; &nbsp; &nbsp;Рисует бордюр по диагонали. Используется для создания кнопок, разбитых по диагонали на две секции &nbsp; &nbsp; &nbsp; 
BF_FLAT BF_SOFT &nbsp; &nbsp; &nbsp; &nbsp;Позволяют получить «плоские» кнопки для создания интерфейса в стиле Office 97 &nbsp; &nbsp; &nbsp; 
BF_MONO &nbsp; &nbsp; &nbsp; &nbsp;Рисует одномерную рамку &nbsp; &nbsp; &nbsp; 
BF_MIDDLE &nbsp; &nbsp; &nbsp; &nbsp;«Заливает» внутреннюю область рамки текущей кистью &nbsp; &nbsp; &nbsp; 
BF_ADJUST &nbsp; &nbsp; &nbsp; &nbsp;Корректирует qrc так, что после отрисовки он соответствует внутренней области рамки. Удобно для дальнейшего рисования. &nbsp; &nbsp; &nbsp; 
<p>Комбинируя флаги в зависимости от текущих свойств компонента можно достаточно просто организовать отрисовку кнопок, реагирующих на различные действия пользователя. Например:</p>
<pre name="code" class="delphi">
procedure TMyButton.Paint;
var
  Rect: TRect;
  Flags: UINT;
  Edge: UINT;
begin
  Rect := Bounds(Left, Right, Width, Height);
  Flags := BF_RECT or BF_MIDDLE or BF_ADJUST;
  if not Ctl3D then
    Flags := Flags or BF_MONO;
  if Flat then
    Flags := Flags or BF_FLAT;
  if Pressed then 
    Edge := EDGE_RAISED
  else
    Edge := EDGE_SUNKEN;
  with Canvas do begin
    DrawEdge(Handle, Rect, Edge, Flags);
    DrawText(Handle, PChar(Caption), -1, Rect,
      DT_SINGLELINE or DT_VCENTER)
  end;
end;
</pre>


Резюме</p>
<p>Таким образом, Delphi, позволяя программисту не вдаваться в тонкости реализации Windows API, в то же время не изолирует программиста от него, предоставляя ему возможность в любой момент взять управление программой в свои руки и добиться от программы именно того поведения, которое требуется для решения каждой конкретной задачи. Грамотное использование возможностей API позволяет писать более компактные и быстродействующие программы, а зачастую &#8211; и сократить объем кода, необходимый для решения задачи. Для того чтобы иметь такую возможность, программист должен понимать, что лежит за классами и функциями VCL и каким объектам Windows они соответствуют.</p>

<p>Тенцер А. Л.</p>
<p>ICQ UIN 15925834</p>
<p>tolik@katren.nsk.ru</p>

<p>
</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
