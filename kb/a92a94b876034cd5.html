<html>
<head>
  <title>Об основах ассемблерных процедур</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Об основах ассемблерных процедур</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->

<p>Глава 1: Об основах ассемблерных процедур</p>
<p>Когда вы захотите добавить хороший и успешный ассемблерный код внутрь проекта на Дельфи, вам потребуется вызвать BASM процедуру, передать в нее переменные и принять обратно результат. Для этого вы должны знать, как работают соглашения о передаче параметров. На первом шаге мы обсудим основное: подпрограммы на ассемблере, получают некоторые переменные для обработки, возвращают впоследствии результаты. Позже, в других главах, мы обсудим, как вызывать другие функции, методы и процедуры из ассемблерного кода с помощью регистров и стека.</p>
<p>1.1. Где размещать ассемблерный код</p>
<p>Ассемблерные инструкции размещаются внутри блока asm...end. Эти блоки могут появляться внутри процедур и функций обычного кода, но я настоятельно не рекомендую поступать таким образом. Гораздо лучше изолировать их в отдельной функции или процедуре. Вставка asm блока внутри обычной процедуры создает сложности для компилятора Паскаля и код становится не эффективным с точки зрения производительности. Переменные, которые обычно передаются через регистры, в этом случае будут передаваться через стек или перезагрузку. Также, это заставляет компилятор адаптировать собственный код к вашему вставленному коду, что делает механизм оптимизации менее эффективным. Так, что это становится правилом помещать ассемблерный код в отдельную процедуру или функцию. Кроме того - это вопрос проектирования. Читабельность и управляемость вашего кода становится выше, если он помещен в свой собственный блок.</p>
<p>Часто, ассемблерный код ассоциируется со скоростью. Поэтому циклы вы также должны по возможности организовывать внутри ассемблерного кода. Это не сложно, а иначе вы просто потеряете множество времени за счет постоянного вызова. Вместо того, чтобы делать так (см. примечание 1):</p>
<pre name="code" class="delphi">
function CriticalCode(...): ...; register;
asm
  ...
  {Here comes your assembler code}
  ...
end;
 
procedure Example;
  var I: Integer;
begin
  I:=0;
  ...
  while I &lt; NumberOfTimes do 
  begin
    CriticalCode(...);
    Inc(I);
  end;
  ...
end;
</pre>
&nbsp;</p>
<p>Вы должны сделать так:</p>
<pre name="code" class="delphi">
function CriticalCode(...): ...; register;
Asm
  ...
  mov ECX,{NumberOfTimes}
  @@loop:
  ...
  {Остальной код}
  ...
  dec ECX
  jnz @@loop
  ...
end;
 
procedure Example;
begin
  ...
  CriticalCode(...);
  ...
end;
</pre>
&nbsp;</p>
<p>Использование цикла в обратном направлении позволяет просто проверять флаг установки нуля после команды dec. Если же цикл начинать с нуля, то потребуется больше на одну команду сравнения с конечным значением, каждый раз при проходе цикла.</p>
<pre name="code" class="delphi">
mov ECX,0
@@loop:
...
inc ECX
cmp ECX,{NumberOfTimes}
jne @@loop
</pre>
&nbsp;</p>
<p>Другая возможность &#8211; это вычесть значение NumberOfTimes из 0 и затем увеличивать переменную цикла, пока она не станет равной нулю. Этот метод обычно используется, когда переменная цикла также является индексом в таблице или массиве в памяти, поскольку механизм кэширования работает лучше, чем при доступе в прямом направлении. Это можно сделать так:</p>
<pre name="code" class="delphi">
xor ECX,ECX
sub ECX,{NumberOfTimes}
@@loop:
...
inc ECX
jnz @@loop
</pre>
&nbsp;</p>
<p>Помните, что в этом случае базовый регистр или адрес, должен указывать на конец массива, вместо его начала.</p>
<p> (1) В данных главах мы специально указываем соглашение о вызове. На самом деле указание register избыточно, так как соглашением по умолчанию является передача параметров через регистры, это сделано исключительно для читабельности (или как дополнительный комментарий) и как напоминание читателю, что параметры передаются через регистры. Этот совет поступил от Christen Fihl, http://HSPascal.Fihl.net</p>
<p>1.2. Код входа/выхода и сохранение регистров</p>
<p>Компилятор автоматически генерирует необходимый код входа и выхода из ассемблерных подпрограмм. </p>
<p>Код входа выглядит так:</p>
<pre name="code" class="delphi">
push EBP
mov  EBP,ESP
sub  ESP, {Размер стека для локальных переменных}
</pre>
&nbsp;</p>
<p>А код выхода так:</p>
<pre name="code" class="delphi">
mov ESP,EBP
pop EBP
ret {Размер стека резервированный для параметров}
</pre>
&nbsp;</p>
<p>Однако, если ваша процедура не имеет никаких локальных переменных или параметров на стеке, то компилятор не делает кода входа/выхода, за исключением инструкции ret.</p>
<p>Код входа сначала сохраняет текущее значение регистра EBP на стеке, поскольку его требуется восстановить при выходе. Затем, устанавливает значение EBP, как базу для доступа к параметрам и локальным переменным, которые также размещаются на стеке. Более подробно мы обсудим этот механизм позже.</p>
<p>Код выхода сначала освобождает память, распределенную для локальных переменных, путем подстройки указателя стека, а затем восстанавливает регистр EBP в его предыдущее состояние и производит возврат в вызвавшую программу. Для всех соглашений, исключая cdecl, процедура сама очищает стек, путем соответствующего варианта инструкции ret, Для соглашения cdecl очисткой стека занимается вызвавшая программа. Снова, все это мы рассмотрим подробнее в дальнейшем.</p>
<p>Внутри вашей функции или процедуры, содержимое регистров EAX, ECX, EDX можно полностью изменять и нет необходимости возвращать их в исходное состояние, кроме того, регистр EAX или его часть часто используется для возврата результата. Если вы изменяете, другие регистры общего назначения (EBX, ESI, EDI), то вы обязаны восстановить их первоначальное состояние до выхода из процедуры. То же самое относится и к регистрам ESP и EBP. Вы также не должны никогда изменять содержимое сегментных регистров&nbsp; (ds, es и ss указывают на один и тот же сегмент; cs имеет свое собственное значение; fs используется Windows и gs резервирован).</p>
<p>Регистр ESP указывает на верхушку стека, а EBP указывает на текущий фрейм стека и генерируется по умолчанию компилятором как код входа. Поскольку каждая инструкция pop и push изменяет содержимое регистра ESP, то его использование не является хорошей идеей для доступа к стеку. Для этих целей зарезервирован регистр EBP. Смотрите Таблицу 1, в которой приведено суммарное описание по использованию регистров в Дельфи.</p>
<p>И в дополнение к регистрам, вы также должны сохранять состояние флага направления. При входе в функцию флаг направления сброшен и если вы его изменяете, то вы должны сбросить его до выхода из функции, сделать это можно с помощью инструкции cld.</p>
<p>И наконец, вы также должны очень осторожно относиться к управляющему слову сопроцессора. Поскольку оно позволяет менять режим точности и округления, а также маскировать определенные исключения, то это может драматически изменить результат вычислений в вашей программе. Если у вас возникла нужда в изменении управляющего слова, то постарайтесь восстановить его значение как можно быстрее. Если вы используете типы Comp или Currency, то не уменьшайте точность!</p>
<p>1.3. Передача информации через регистр</p>
<p>При использовании соглашения по умолчанию, передачу через регистры, Дельфи может передавать до двух методов или до трех параметров через регистры процессора. Это означает, что нет необходимости генерировать фрейм стека для передачи параметров. Не все типы могут быть переданы через регистры, а только те, которые помещаются полностью в регистр. Поэтому, многие сложные типы передаются или через стек, или через память, и вместо самих типов передается указатель через регистр. Это означает, что любой тип может быть передан через регистр, как указатель, за исключением указателей методов, которые всегда передаются как два 32-разрядных указателя, размещенных на стеке.</p>
<p>Текущее поколение процессоров, для которых написана данная статья, обычно называются как Intel Pentium процессоры, имеет регистры шириной в 32 бита. Когда передаваемая информация не полностью использует регистр (для типов слово и байт), то используется, только часть регистра, байты используют младшие восемь бит, например al и для слов младшее слово, например ax. Указатели всегда 32-битные (по крайней мере, пока не появятся 64-битные процессоры) и занимают весь регистр полностью, например eax. В случае переменных типа байт и слово оставшаяся часть регистра не определена и вы не должны делать никаких предположений относительно его содержимого. Например, при передаче байта в функцию, через регистр al, остальные 24 бита регистра eax не определены и вы, конечно, не можете рассчитывать на то, что они равны нулю. Вы просто можете использовать инструкцию and для&nbsp; очистки оставшихся бит.</p>
<pre name="code" class="delphi">
and EAX,$FF {беззнаковый байт в AL, очистка старших 24 бит}
</pre>
<p>или</p>
<pre name="code" class="delphi">
and EAX,$FFFF {беззнаковое слово в AX, очистка старших 16 бит}
</pre>
&nbsp;</p>
<p>Когда вы передаете знаковые параметры (ShortInt или SmallInt), вы должны расширить их с учетом знака. Для расширения знака для байтового параметра до двойного слова, вы должны использовать две инструкции:</p>
cbw&nbsp; {расширение al до ax}</p>
cwde {расширение ax до EAX}</p>
<p>Для демонстрации, напишите следующую тестовую подпрограмму:</p>
<pre name="code" class="delphi">
function Test(Value: ShortInt ): LongInt; register;
asm
 
end;
</pre>
&nbsp;</p>
<p>Разместите кнопку и метку на форме и поместите следующий код в обработчик OnClick:</p>
<pre name="code" class="delphi">
var I : ShortInt ;
begin
  I := -7;
  Label1.Caption := IntToStr(Test(I));
end;
</pre>
<p>Запустите проект и нажмите кнопку. Тестовая процедура принимает параметр типа ShortInt  через al. И возвращает результат типа integer через регистр EAX, который возвращает результат неизменным. Вы можете просто считать, что EAX имеет неизмененное значение при возврате. Теперь изменим функцию следующим образом и запустим проект снова на выполнение:</p>
<pre name="code" class="delphi">
function Test(Value: ShortInt ): LongInt; register;
asm
  cbw
  cwde
end;
</pre>
&nbsp;</p>
<p>Единственным соглашением, согласно которому регистры используются для передачи параметров, это соглашение с ключевым словом register, которое также является соглашением по умолчанию. Все другие соглашения используют стек для передачи параметров в функции или процедуры. И конечно, если вы передаете более двух или трех параметров, то стек также используется для передачи оставшихся параметров. В заключение, некоторые параметры всегда передаются через стек - это указатели методов, которые в действительности состоят из двух 32-битных указателей и параметров с плавающей запятой. Обзор можно найти в таблице 2.</p>
<p>1.4. Передача информации через стек</p>
<p>При использовании соглашения&nbsp; по передаче параметров через регистры и передаче более двух указателей метода или трех параметров, остальные передаются через стек. Другие соглашения также используют стек для передачи параметров.</p>
<p>Обычно, для доступа к параметрам на стеке вы должны обращаться к ним через адресацию с помощью регистра EBP. Код входа по умолчанию, который генерирует компилятор, устанавливает регистр EBP на данный фрейм. Таким образом, использование EBP с нужным смещением позволяет иметь доступ к параметрам на стеке и к локальным переменным. Посмотрим на пример с использованием соглашения о вызове pascal. </p>
<p>Данное соглашение помещает параметры слева, направо. Для примера, в следующем объявлении:</p>
<pre name="code" class="delphi">
function Test(First, Second, Third: Integer): Integer; pascal;
</pre>
&nbsp;</p>
<p>мы имеем три 32-битных параметра типа integer, и каждый параметр помещается на стек следующим образом:</p>
First</p>
Second</p>
Third</p>
ESP -&gt;</p>
<p>Инструкция вызова добавляет адрес возврата на стек, и стек теперь выглядит следующим образом:</p>
First</p>
Second</p>
Third</p>
ESP -&gt;</p>
Return Address</p>
<p>Компилятор автоматически генерирует код входа (см. главу 1.2) для сохранения текущего значения регистра EBP и затем копирует регистр ESP в EBP для доступа к фрейму стека:</p>
First</p>
Second</p>
Third</p>
Return Address</p>
EBP, ESP-&gt;</p>
Previous EBP</p>
<p>В данной точке, мы имеем доступ к параметрам на стеке, как смещение относительно регистра EBP. Поскольку адрес возврата находится на стеке между текущей верхушкой стека и действительными параметрами, мы можем получить их следующим образом:</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 19px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="17">First</td><td>= &nbsp; &nbsp; &nbsp; &nbsp;EBP + $10 &nbsp; &nbsp; &nbsp; &nbsp;(EBP + 16)</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 19px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="17">Second</td><td>= &nbsp; &nbsp; &nbsp; &nbsp;EBP + $0C &nbsp; &nbsp; &nbsp; &nbsp;(EBP + 12)</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 19px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="17">Third</td><td>= &nbsp; &nbsp; &nbsp; &nbsp;EBP + $08 &nbsp; &nbsp; &nbsp; &nbsp;(EBP + 8)</td></tr></table></div><p>В действительности, вы будете просто ссылаться на них по их именам, компилятор сам рассчитает необходимые смещения самостоятельно. Так, для выше описанного случая, напишите:</p>
mov EAX,First</p>
<p>Компилятор превратит их в следующий код:</p>
mov EAX,[EBP+0x10]</p>
<p>Это избавляет вас от самостоятельного расчета смещений и делает код более читабельным. Так что вы должны использовать имена везде, где только возможно (практически всегда), вместо расчета их вручную смещений.</p>
<p>Данные, переданные через стек, всегда занимают 32 бита, даже если вы передаете байт, оставшиеся биты просто не определены.</p>
<p>&nbsp;</p>
<p>1.5. Локальные переменные</p>
<p>Так же как и в обычной процедуре, вы можете использовать локальные переменные для хранения временных значений. Они объявлятся - с помощью директивы var и размещаются на стеке. Компилятор генерирует необходимый код пролога, для резервирования необходимого места на стеке, вместе с параметрами и обеспечивает доступ по имени. Вы помните, что функция объявляется следующим образом:</p>
<pre name="code" class="delphi">
function Test(First, Second, Third: Integer): Integer; pascal;
</pre>
&nbsp;</p>
<p>Для временного хранения объявим переменную типа&nbsp; integer, для этого сделаем следующее объявление:</p>
<pre name="code" class="delphi">
var MyTemp: Integer;
</pre>
&nbsp;</p>
<p>В результате компилятор сгенерирует следующий код и выделит место на стеке. Обратим внимание, что фрейм стека будет выглядеть следующим образом без использования локальных переменных.</p>
First</p>
Second</p>
Third</p>
Return Address</p>
EBP, ESP-&gt;</p>
Previous EBP</p>
<p>Для создания места на стеке для локальной переменной MyTemp, компилятор добавляет инструкцию push, теперь стек выглядит следующим образом:</p>
First</p>
Second</p>
Third</p>
Return Address</p>
EBP -&gt;</p>
Previous EBP</p>
ESP -&gt;</p>
? (MyTemp)</p>
<p>Для адресации этих локальных переменных опять же используется смещение относительно регистра EBP. Для примера, переменная MyTemp доступна через EBP-4 (напомню: регистр EBP инициализируется компилятором в коде входа). И еще раз, нет необходимости рассчитывать это смещение вручную, достаточно использовать имя переменной MyTemp:</p>
mov EAX,MyTemp</p>
<p>будет оттранслировано в следующий код:</p>
mov EAX,[EBP-4]</p>
<p>Содержимое переменных не инициализируется при входе, и вы не должны делать никаких предположений об их начальных значениях. Поэтому вы должны сами проинициализировать их до использования:</p>
mov MyTemp,0</p>
<p>Так же, вы должны с осторожностью объявлять и использовать локальные переменные. Они добавляют лишнюю нагрузку по созданию места на стеке и на освобождение при выходе. Еще важно то, что доступ к основной памяти гораздо медленнее, чем доступ к регистрам процессора. Так, что пытайтесь использовать регистры везде, где это возможно, для хранения временных переменных, вместо использования локальных переменных. В обычном коде, при включенной оптимизации, компилятор так же пытается использовать регистры для локальных переменных.</p>
<p>&nbsp;</p>
<p>1.6. Возврат информации через регистры процессора</p>
<p>В большинстве случаев (зависит от типа результата), функция возвращает результат через&nbsp; регистры процессора. Напомним, что в отличие от передачи параметров в функцию, где в большинстве соглашений используют стек, для возврата результата, все соглашения используют регистры для допустимых типов!</p>
<p>Таблица 3 содержит обзор о вариантах возврата результатов. В большинстве случаев, результат возвращается через регистр EAX или FP(0). Особый случай, когда в результате возвращается длинная строка или другой тип, возвращаемый через указатель. В случае длинных строк, динамических массивов, больших множеств, вариантов и больших записей, переданных через параметр с директивой var, используется 32-битный указатель на результат. Так, где же хранится действительное содержимое результата (например, длинных строк)? Ответ на это в том, что вы должны выделить место в куче, заполнить его данными, и вернуть указатель на эту область памяти через переменную Result. Заметим, что, для множеств, записей и массивов, которые могут разместиться в регистре, переменная Result возвращает их через регистр. Только для длинных строк, вариантов и множеств, записей и массивов, которые занимают свыше 32 бит, переменная Result возвращает указатель на дополнительный указатель, размещенный функцией, аналогично директиве var параметра (мы рассмотрим директиву параметра var в главе 1.9). </p>
<p>Не беспокойтесь, если что-то сейчас не понятно, позже мы рассмотрим эти типы подробнее.</p>
<p>Теперь поясним это на примере. Функция PlusMinusLine возвращает длинную строку, состоящую из последовательности плюсов и минусов, для формирования строки. Например, когда вы напишите так S:=PlusMinusLine(9), то S должна получить значение: "-+-+-+-+-". </p>
<p>Декларация функции следующая:</p>
<pre name="code" class="delphi">
function PlusMinusLine(L: Integer): AnsiString; register;
</pre>
&nbsp;</p>
<p>Функция принимает один параметр: длину строки символов (L). Поскольку мы используем соглашение по умолчанию, то параметр передается через регистр EAX. Функция должна вернуть длинную строку, Что в действительности означает указатель на область памяти, содержащей нашу строку. Вы можете использовать переменную Result для обращения к этой области, но поскольку ее поведение аналогично var, то в этом случае @Result эквивалентно регистру EDX (второй параметр отдельной функции передается через регистр EDX, при использования соглашения register)! Подробности мы рассмотрим в главе 1.9. EDX не содержит самого указателя, но указатель на область памяти для этого указателя! Тем не менее, пока еще не распределена память для нашей длинной строки. Будем использовать функцию NewAnsiString из модуля system для размещения памяти в куче и установке длины строки. Функция NewAnsiString устанавливает длину новой строки, которая передается через регистр EAX и возвращает адрес этой строки в том же регистре. Если же мы не вызовем функцию NewAnsiString (или другую функцию или процедуру, которая выделит память в куче для нашей длинной строки), то переменная Result не будет содержать действительного указателя и мы можем получить ошибку доступа (access violation) если попытаемся использовать его.</p>
<pre name="code" class="delphi">
function PlusMinusLine(L: Integer): AnsiString; register;
asm
push EDIpush ESIpush EBXmov ESI,EDX {Указатель памяти на Result}mov EBX,EAX {EBX хранит длину параметра}call System.@NewAnsiStringmov EDI,EAX {EDI используется для заполнения строки}mov [ESI],EDImov ECX,EBXshr ECX,2 {обрабатываем по 4 байта за раз}test ECX,ECXjz @@remainmov EAX,'+-+-'
@@loop:
mov [EDI],EAXadd EDI,4dec ECXjnz @@loop@@remain: {заполняем оставшие байты, если length/4 не ноль}mov ECX,EBXand ECX,3jz @@endingmov EAX,'+-+-'
@@loop2:
mov BYTE PTR [EDI],alshr EAX,8inc EDIdec ECXjnz @@loop2
@@ending:
mov EAX,ESI {для совместимости: возврат указателя через EAX}pop EBXpop ESIpop EDI
end;
</pre>
&nbsp;</p>
<p>Для облегчения понимания, данного примера пришлось пожертвовать некоторой эффективностью. Для ускорения за раз одновременно обрабатывается по 4 байта для заполнения строки. Тем не менее, можно сделать еще быстрее, если использовать указатель в EDI на конец строки и использовать отрицательный счетчик в ECX, постепенно увеличивая его до нуля и используя его как индекс ([EDI+ECX*4]), что также сделало бы не нужным увеличение регистра EDI после каждой итерации. Это прекрасный повод для читателя переписать эту функцию данным образом и сравнить результаты выполнения. Также, может быть, вы захотите уменьшить количество циклов для еще большей эффективности. Например, обрабатывать по 8 байт за каждую итерацию, уменьшив этим количество переходов.</p>
<p>Как видим, возврат информации через регистры не всегда самый простой путь, особенно для структурных переменных типа длинных строк.</p>
<p>&nbsp;</p>
<p>1.7. Возврат информации через стек процессора</p>
<p>Даже если на первый взгляд кажется странным возвращать результат через стек, в некоторых случаях это единственный путь для возврата результата. Например, если результат не помещается в регистр или не помещается на стек сопроцессора. Вы должны думать об коротких строках, записях и множествах, которые не помещаются в регистр. Но мы не говорим о таких типах данных, которые возвращаются, как указатель на результат и не говорим о результатах, передаваемые как var параметр. В предыдущей главе, мы уже обсуждали эти принципы. Тем не менее, когда размер результата не известен заранее, как для длинных строк до их создания, некоторые типы занимают фиксированное количество байт в памяти, и место для их размещения может быть выделено компилятором еще до вызова функции. Это то, что в действительности применимо для записей, статических массивов и больших множеств, также и для коротких строк.</p>
<p>Допустим, что у нас есть запись TMyRecord, объявленная следующим образом:</p>
<pre name="code" class="delphi">
type
  TMyRecord = record
    A: Integer;
    B: Double;
    C: Integer;
  end;
</pre>
&nbsp;</p>
<p>Компилятор знает, что эта запись занимает 16 байт в памяти. Поэтому, мы можем объявить функцию, которая возвращает запись как результат, объявление будет выглядеть так:</p>
<pre name="code" class="delphi">
function MyFunction(I: Integer): TMyRecord; register;
</pre>
&nbsp;</p>
<p>Как отмечено в главе 1.6, переменная Result передается в функцию как дополнительный var параметр. Поэтому регистр EDX хранит указатель на результат. Но в отличие от примера с AnsiString, память для результата уже выделена компилятором до входа в функцию, если быть точным, то на стеке. Поэтому нам не нужно самостоятельно выделять память в куче. Достаточно заполнить эту память, которую компилятор резервировал для этой цели. Надо быть только острожным и не выйти за пределы отведенной памяти! Если же это произойдет, то будет разрушен стек и как результат - повисание программы или ошибка доступа (access violation).</p>
<p>В связи с тем, что память уже выделена компилятором, и регистр EDX содержит указатель на эту память (в действительности это стековая память), мы можем просто использовать регистр EDX для заполнения результата:</p>
mov [EDX],EAX</p>
<p>Мы заполнили первое двойное слово (член записи A) содержимым регистра EAX. Заметим, что в данном случае мы не заботились о расчете смещения, относительно регистра EDX, для доступа к нужному члену записи. Но вы должны все-таки написать так, чтобы позволить компилятору сделать эту работу за вас:</p>
mov [Result].A,EAX</p>
<p>Это то же самое, что и выше, но компилятор знает, что Result - это указатель, хранящийся в регистре EDX, и вы можете использовать более ясную точечную нотацию для адресации членов записи. Компилятор сам рассчитает смещение. Строго рекомендуется использовать именно точечную нотацию везде, где только возможно.</p>
<p>&nbsp;</p>
<p>1.8. Возврат информации через стек сопроцессора</p>
<p>Функции, которые возвращают результат с плавающей запятой, просто должны возвращать результат в ST(0). Ниже вы найдете пример. Помните, что сопроцессор обрабатывает внутри все числа, как 10-байтные расширенные числа. Указывая формат результата (single, double, extended, comp, currency, и т.д.) мы только указываем, как число будет записано в ST(0) и затем в память. В примере функции CalcRelatMass показано это. Передаются два параметра, масса и скорость тела и производится расчет относительной массы, согласно теории относительности. Оба параметра: масса (m) и скорость (v), передаются в функцию как double, результат так же возвращается как double.</p>
<pre name="code" class="delphi">
function CalcRelatMass(m,v: Double): Double; register;
  const LightVelocity: Integer = 299792500;
asm
{Расчет относительной массы по следующей фформуле: Result = m / Sqrt(1-vІ/cІ), где c = скорость света,m масса и v скорость движения объекта} fild LightVelocityfild LightVelocityfmulp {расчет cІ}fld vfld vfmulp {расчет vІ}fxchfdivp {vІ/cІ}fld1fxchfsubp {ST(0)=1-(vІ/cІ)}fsqrt {корень ST(0)}fld mfxchfdivp {деление массы на корень результата}
end;
</pre>
&nbsp;</p>
<p>Оба параметра, m и v, передаются в функцию через стек. Поскольку они типа double, то они занимают по 8 байт стека, который выглядит следующим образом:</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 19px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="17">EBP+0x10</td><td>m</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 19px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="17">EBP+0x08</td><td>v</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 19px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="17">EBP+0x04</td><td>адрес возврата</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 19px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="17">EBP -&gt;</td><td>предыдущий EBP</td></tr></table></div><p>Вы никогда не должны забывать, что внутри сопроцессора они обрабатываются как 10-байтные числа с плавающей запятой. Результат остается в ST(0) (верхушка стека математического сопроцессора). Это извлекается кодом, который вызвал функцию.</p>
<p>Вы можете изменять точность и режим округления вычислений путем изменения контрольного слова процессора. Хотя вы точно знаете, что делаете, но это не поощряется, поскольку смена контрольного слова влияет на все вычисления для всего вашего приложения. Проблему обостряет то, что некоторые DLL также изменяют контрольное слово. Это иногда может привести к непредсказуемым результатам&nbsp; или различным результатам в зависимости от Операционной Системы, на которой запускается программа или в зависимости от того, какие версии DLL реально используются. Как заметил Robert Lee в одном из сообщений в группе новостей, вы должны особенно избегать этого, путем загрузки контрольного слова из глобальной переменной Default8087CW (объявлена в модуле System) до выполнения важных процедур.</p>
<p>Так же очень важно полное понимание природы чисел с плавающей запятой при использовании их внутри вашего кода. Я написал отдельную статью, в которой обсуждается основы. Статья доступна на моих страницах по Дельфи на сайте http://www.optimalcode.com/Guido/fpv.html.</p>
<p>&nbsp;</p>
<p>1.9. Передача параметров по зничению и ссылке</p>
<p>Имеется огромная разница между передачей параметров по значению и по ссылке (через директиву var). Например, следующее объявление функции:</p>
function MyFunction(I: Integer): Integer; register;</p>
<p>Значение параметра I будет передано через регистр EAX (см. таблицу 2 для обзора, как параметры разного типа передаются в функцию/процедуру). Например, когда I=254, EAX подобен $000000FE. Но следующее объявление:</p>
function MyFunction(var I: Integer): Integer; register;</p>
<p>передаст не значение I (254 в нашем примере), а указатель на местонахождение, где&nbsp; переменная I записана в памяти (например, $0066F8BC) и этот указатель будет помещен в регистр EAX! При передаче параметра с помощью ключевого слова var, вы всегда передаете 32-битный указатель на переменную (который естественно помещается в регистр соглашения register).</p>
<p>Посмотрим на простой пример: допустим, мы желаем, чтобы наша функция вернула сумму целочисленного числа и 12 (Конечно, это очень бессмысленный пример, он нужен просто для демонстрации), передадим параметр по значению (функция вернет результат в регистре EAX):</p>
<pre name="code" class="delphi">
function MyFunction(I: Integer): Integer; register;
asm
  add EAX,12
end;
</pre>
&nbsp;</p>
<p>В случае же передачи по ссылке, мы должны написать так:</p>
<pre name="code" class="delphi">
function MyFunction(var I: Integer): Integer; register;
asm
  mov EAX,[EAX] {Загрузить значение параметра I через указатель}
  add EAX,12
end;
</pre>
&nbsp;</p>
<p>При использовании директивы const правила те же, как для переменных, передаваемых по значению. Например, для объявления:</p>
<pre name="code" class="delphi">
function MyFunction(const I: Integer): Integer; register;
</pre>
&nbsp;</p>
<p>Регистр EAX будет содержать значение I, а не указатель.</p>
<p>Как мы обсуждали в главе 1.6, длинные строки, динамические массивы, варианты, большие множества и записи возвращаются с помощью дополнительного var параметра. Позже, в других главах, мы обсудим эти типы более детально. </p>
</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
