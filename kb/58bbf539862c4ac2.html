<html>
<head>
  <title>Реализация протоколов</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Реализация протоколов</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->
<p>10. Реализация протоколов</p>
В Indy реализовано большинство распространенных протоколов. Но все равно бывают случаи, когда требуется реализовать протокол самостоятельно. Основная причина в необходимости реализации состоит в том, что нужный протокол отсутствует.</p>
Первый шаг в понимание что же надо реализовать. Имеется три базовых типа протоколов:</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">1.</td><td>Стандартный &#8211; эти протоколы относятся к Интернет стандартам. Для понимания просто найдите в RFC нужный протокол. В RFC&nbsp; протокол рассмотрен в подробностях.</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">2.</td><td>Пользовательский &#8211; пользовательские протоколы используются, когда отсутствует нужный протокол. Создание пользовательского протокола будет описано позже.</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">3.</td><td>Разработчика &#8211; это протоколы, предназначенные для общения с собственными системами или оборудованием. Протоколы разработчика &#8211; это пользовательский протокол, разработанный программистом, а вы общаетесь с ним. Я желаю вам удачи, поскольку большинство протоколов разработчика реализованы специалистами по оборудованию, которые имели один курс обучения в колледже и не имеют опыта разработки протоколов.</td></tr></table></div>Большинство протоколов общаются, с помощью текста, и если только у вас нет особых причин, то и вы тоже должны поступать также. </p>
Первым шагом построения клиента или сервера &#8211; это понять протокол. Для стандартных протоколов это может быть сделано с помощью чтения RFC. Для пользовательских протоколов вы его должны сами разработать.</p>
Большинство протоколов используют просто текст. Общение означает посылку команд и получение ответов, а возможно и данных. Текст делает протокол более простым для отладки и позволяется использовать любые языки программирования и операционные системы.</p>
Код состояния традиционно трехзначный номер. Не имеется стандарта на определение кодов состояния, но многие протоколы используют де-факто следующие соглашения:</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>1xx - информационные</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>2xx - успешные</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>3xx &#8211; временные ошибки</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>4xx &#8211; постоянные ошибки</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>5xx &#8211; внутренние ошибки</td></tr></table></div>Каждой ошибке обычно назначается уникальный номер, но некоторые протоколы используют номера повторно и только предоставляют уникальный цифровой номер для каждой команды, а не протокола.</p>
10.1. Терминология протокола</p>
Перед обсуждением реализации протокола рассмотрим некоторые термины.</p>
10.1.1. Простой текст (plain text)</p>
Простой текст (plain text) означает, что все команды (commands) и ответы (replies) используют только 7-битный код ASCII. Если передача данных в откликах (responses) допустима в двоичном виде, то почти все команды протокола и ответы используют простой текст. Двоичный код никогда не должен использоваться в командах и ответах, если на это не будет веских оснований.</p>
Использование простого текста упрощает отладку и тестирование. Это также означает переносимость между операционными системами и языками программирования.</p>
10.1.2. Команды (commands)</p>
Команда это текстовая строка, которая посылается клиентом серверу для запроса информации или выполнения определенных действий. Примеры команд: HELP, QUIT, LIST.</p>
Команды могут содержать дополнительные параметры, разделенные пробелами.</p>
Пример:</p>
GET CHARTS.DAT</p>
GET - это команда, а CHARTS.DAT &#8211; это параметр. В данном примере используется только один параметр, но команды могут содержать несколько параметров. Обычно параметры разделены пробелами, аналогично параметрам в DOS или в командной строке.</p>
Команды всегда кодируются на английском языке. Это может казаться предвзятым, тем не менее это общая практика, как в техническом мире,&nbsp; так и в мире бизнеса. Если английский не используется, то протокол не очень применим.</p>
Один из плохих примеров последствий локализации команд, является Microsoft Office. Microsoft Office может быть автоматизирован, с помощью OLE. Тем не менее, Microsoft локализовал имена методов и свойств объектов. Это означает, что если вы пишите приложения с помощью Microsoft Office Automation в американской версии, то ваше приложение не будет работать во французской версии.</p>
10.1.3. Ответы (reply)</p>
Ответы &#8211; это короткий ответ на посланную команду. Ответ содержит информацию о состоянии &#8211; успешно ли ошибка, и иногда содержит небольшое количество данных.</p>
Например, если команда GET customer.dat, вернет ответ 200 OK, это будет означать, что команда воспринята и будет обработана. Ответы обычно состоят только из одной строки, но могут состоять и из нескольких строк.</p>
В отличие от команд, текстовая часть ответа может быть локализована на другой язык, если она соответствует ограничению 7-бит ASCII. Поскольку протокол использует цифровую часть, а текстовая часть используется только для конечного пользователя и для отладки.</p>
10.1.4. Отклики (response)</p>
Отклик &#8211; это часть данных, которая возвращается в ответ на команду. Отклики дополнительны и не присутствуют во всех команда. Отклики посылаются после ответа, для распознавание правильный ли ответ получен и какой формат этого отклика.</p>
Отклики могут быть текстовыми или двоичными. Если отклик текстовый, то обычно этот отклик в формате RFC откликов.</p>
10.1.5 Переговоры (conversations)</p>
Большинство протоколов аналогичны переговорам. Некоторые очень просты, а некоторые нет, но обычно они все равно в простом текстовом формате.</p>
Переговоры означают следующую структуру:</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">1.</td><td>отправка команды</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">2.</td><td>возврат состояния</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">3.</td><td>дополнительные данные отклика</td></tr></table></div>Вернем обратно к примеру получения почтовых кодов, в котором обмен выглядит следующим образом:</p>
Client: lookup 37642 77056</p>
Server: 200 Ok</p>
Server: 37642: CHURCH HILL, TN</p>
Server: 77056: HOUSTON, TX</p>
Server: .</p>
Разделив на отдельные куски, разговор будет выглядеть так:</p>
Команда:</p>
Client: lookup 37642 77056</p>
Ответ:</p>
Server: 200 Ok</p>
Отклик:</p>
Server: 37642: CHURCH HILL, TN</p>
Server: 77056: HOUSTON, TX</p>
Server: .</p>
Каждая из этих частей будет объяснена ниже.</p>
10.2 RFC - определения</p>
В настоящем нет действующих стандартов для терминов, обсуждаемых в данной главе. Тем не менее, эти термины базируются на квази-стандартах, на которых работают все тексто-ориентированые RFC протоколы.</p>
Единственное значимое исключение- это протокол POP3. Это мистерия, почему разработчики решили идти своим путем, вместо пути RFC. Протокол POP3 в реальности очень ограничен и не предлагает нужной дополнительной функциональности к протоколу. Это обычная диверсия. </p>
Протокол IMAP4, который был предложен как наследник POP3, продолжил эту порочную практику и так же использует не стандартный механизм. Протокол IMAP4 не получил широкого распространения и POP3 остается стандартным протоколом для почты.</p>
После этих двух упоминаний, текстовый протокол все еще остается квази-стандартным. Этот квази-стандарт общий путь посылки команды и получение ответов и откликов.</p>
10.2.1. RFC - коды состояния</p>
Коды состояния RFC имеют следующую форму:</p>
XXX Status Text</p>
Где XXX это цифровой код в диапазоне 100-599.</p>
Трехзначный цифровой номер означает ответ, который в ран-тайм, служит для определения результата выполнения команды. Обычно присутствует дополнительный текст, показываемый пользователю или для отладки. В этом случае, обычно используется английский язык, но может быть и локализован, если будет удовлетворять 7-битному коду ASCII. В некоторых случаях, когда данные короткие, данные возвращаются в дополнительном текстовом поле. В этих случаях данные все рано должны быть 7-бит ASCII, но протокол сам определяет язык и ограничения форматов. В большинстве случаев, эти данные языко-независимы (language neutral). Например, команда "TIME", возвращает "15:30" в дополнительном текстовом поле.</p>
Пример RFC ответа:</p>
404 No file exists</p>
404 это цифровой отклик и "No file exists" это дополнительное текстовое сообщение. Только код 404 должен быть интерпретирован программой и код 404 должен быть точно определен протоколом именно для этого. Текстовое сообщение обычно используется для отладки, ведения логов или для показа пользователю. Текстовое сообщение может иметь различные формы, от реализации к реализации и может быть локализировано на другие&nbsp; языки. Языки которые не соответствуют требованиям кода 7-бит ASCII должны быть транслитеризированы в английские символы. </p>
Цифровая часть может быть назначена любым значениям. Тем не менее существует общее соглашение:</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>1xx - информационные</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>2xx - успешные</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>3xx &#8211; временные ошибки</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>4xx &#8211; постоянные ошибки</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>5xx &#8211; внутренние ошибки</td></tr></table></div>Числа обычно уникальные, но не всегда. Если вы назначите 201 для "File not found", многие команды могут отвечать этим кодом и значение всегда одно. В некоторых редких случаях, значение числа зависит от примененной команды. В этом случае, каждая команда назначает специфическое значение each command assigns specific meanings to each numeric reply.</p>
Цифровые коды, заканчивающие на 00, то есть 100, 200, и так далее резервированы для общих ответов, которые не имеют специального значения связанного с ними. 200 наиболее часто с "Ok".</p>
Коды состояния могут находиться на нескольких строках и содержать большие текстовые сообщения. В этом случае, остальные строки, за исключением последней должны содержать код символа тире сразу после номера, вместо пробела.</p>
Пример такого ответа:</p>
400-Unknown Error in critical system</p>
400-The server encountered an error and has no clue what caused it.</p>
400-Please contact Microsoft technical support, or your local</p>
400-tarot card reader who may be more helpful.</p>
<p>400 Thank you for using our products!</p>
10.2.1.1. Примеры</p>
Здесь пример некоторых кодов состояния, полученные от HTTP протокола. Как вы видите они относятся к разным категориям по первой цифре.</p>
200 Ok</p>
302 Redirect</p>
404 Page not found</p>
500 Internal Error</p>
Если вы видите 500 Internal Error, велик шанс, что вы используете Microsoft IIS. (Грубый наезд :-))</p>
10.2.2. RFC &#8211; ответ (reply)</p>
RFC ответ, возвращает код состояния.</p>
10.2.3. RFC &#8211; отклик (response)</p>
RFC отклик это текстовый ответ, ограниченный строкой с одной точкой в начале. Если данные содержат строку, которая содержит точку, то она перекодируется в две точки перед передачей, и обратно преобразовываться в одну при приеме.</p>
RFC отклики очень применимы, когда заранее неизвестно количество возвращаемых данных. Это используется в HTTP, Mail, News и других протоколах.</p>
Методы Indy, которые поддерживают RFC отклики &#8211; это Capture (для приема) и WriteStrings (для передачи).</p>
10.2.4. RFC - транзакции</p>
Транзакция RFC это общение, которое состоит из команды, ответа и дополнительного отклика, все в формате RFC. Обработчики команд и другие части Indy построены на транзакциях RFC.</p>
Примет транзакции:</p>
GET File.txt</p>
201 File follows</p>
Hello,</p>
Thank you for your request, however we cannot grant your</p>
request for funds for researching as you put it in your</p>
application "A better mouse trap".</p>
Thank you, and please do not give up.</p>
.</p>
10.3. Класс TIdRFCReply</p>
TIdRFCReply обладает возможностью посылки и приема RFC ответов. TIdRFCReply имеет три основных свойства: NumericCode, Text и TextCode. NumericCode и TextCode взаимно исключающие. TextCode &#8211; свойство, которое управляет такими протоколами, как POP3 и IMAP4.</p>
Для генерации ответа, установите свойство NumericCode (или TextCode) и дополнительно введите текст в свойство Text. Свойство Text типа TStrings позволяет многострочные ответы.</p>
TIdRFCReply имеет методы для записи форматированных ответов, и также для разбора текста в TIdRFCReply.</p>
TIdRFCReply используется для посылки ответов на команды, и также для свойств ReplyException, ReplyUnknown и Greeting properties класса TIdTCPServer.</p>
10.4. Класс ReplyTexts</p>
Цифровой код в ответе обычно уникален для каждой ошибки. Например, протокол HTTP&nbsp; использует код 404 для "Resource not found". Многим командам разрешено возвращать код 404 как ошибку, но код 404 всегда должен означать одну и туже ошибку. Для преодоления дублирования текстов для ошибки 404 класс TIdTCPServer имеет свойство ReplyTexts.</p>
Свойство ReplyTexts &#8211; это коллекция экземпляров TIdRFCReply, которые могут быть обработаны, как в ран-тайм, так и в дизайн-тайм. Свойство ReplyTexts используется для обработки списка текстов, которые связаны с цифровым кодом. Когда свойство TIdRFCReply используется в TCPServer, который имеет цифровой&nbsp; код, но не имеет текстовой части, Indy просматривает в ReplyTexts и использует строку от туда.</p>
Вместо включения текста, в каждый ответ 404 посмотрите ниже:</p>
ASender.Reply.SetReply(404, 'Resource Not Found');</p>
Затем может использоваться следующий код:</p>
ASender.Reply.NumericCode := 404;</p>
Перед тем, как Indy посылает ответ, она сначала устанавливает свойство Text из найденного в ReplyTexts. Это позволяет хранить все тексты ответов в одном месте, позволяя легко управлять ими.</p>
10.5. Курица или яйцо?</p>
При построении системы, в которой вы должны построить, и сервер, и клиента, возникает следующий вопрос - "что делать сначала, клиента или сервера?". Оба нужны одновременно для отладки.</p>
Ответ прост, проще построить сервер первым. Для тестирования клиента, вы должны иметь сервер. Для тестирования сервера вам нужен клиент. Но поскольку, протоколы как правило текстовые, то клиент легко эмулировать с помощью телнета.</p>
Для тестирования, подсоединитесь к серверу на его порт. В командной строке введите:</p>
Telnet newsgroups.borland.com 119</p>
Теперь нажмите клавишу enter. </p>
На Windows 95/98/ME и NT это может выглядеть немного иначе, чем на Windows 2000 или на Windows XP, но результат должен быть таким же. Другие версии Windows загружают телнет, как новое приложение в свом окне. Выше показанный рисунок относится к Windows XP', в котором телнет является консольным приложением.</p>
Команда "Telnet newsgroups.borland.com 119" указывает клиенту телнета, подсоединиться к newsgroups.borland.com на порт 119. Порт 119 используется для протокола NNTP (News). Подобно подсоединения к серверу новостей Borland, телнет может использоваться для соединения с любым сервером, использующим текстовый протокол.</p>
Для отсоединения от сервера новостей введите команду "Quit" и нажмите enter.</p>
10.6. Определение пользовательского протокола</p>
Задача сетевого разработчика состоит не только во взаимодействии с существующими системами, но часто и в создании собственных. В таком случае требуется создание своего протокола.</p>
Первым шагом построения клиента или сервера &#8211; это разработка протокола. Для стандартных протоколов, это решается изучением соответствующего RFC. Если же протокол не стандартный, или уже определен, то должен быть определен.</p>
При определении протокола, должны быть сделаны следующие решения:</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>Текстовые или двоичные команды? Пока нет особых требований, используйте текстовые команды. Текстовые команды проще для понимания и для отладки.</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>TCP или UDP? Это определяется от требований к протоколу. Изучите все характеристики и решите с осторожностью. В большинстве случаев TCP правильный выбор.</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>Порт &#8211; каждому серверному приложению требуется выделенный порт для прослушивания. Порты ниже 1024 резервированы и никогда не должны использоваться, кроме реализации протокола, которому уже назначен порт ниже 1024.</td></tr></table></div>После определения команд, также должны быть определены ответы и отклики.</p>
10.7. Симуляция другой стороны (Peer Simulation)</p>
Традиционно естественный путь построения клиента и сервера &#8211; это сначала построение сервера, а затем клиента или построения их параллельно. Но Indy имеет возможность построить клиент или сервер, отдельно друг от друга. В некоторых случаях, один может быть построен без необходимости доступа к другому. В таких случаях может использоваться эмуляция (видимо симуляция, судя по названию главы) другой стороны. Эмуляция другой стороны будет обсуждена позже в главе 14. Отладка.</p>
10.8. Протокол получения почтового кода</p>
В данной главе более подробно обсуждается Протокол получения почтового кода, который был представлен&nbsp; ранее в его клиенте. Сам сервер будет обсужден позже.</p>
Проект был разработан так, чтобы быть как можно более простым. Сервер получения почтового кода (Zip код в Америке) позволяет клиенту запросить город и штат, к которому относится почтовый код.</p>
Примерные данные, которые использует сервер, относятся к американским почтовым кодам, которые у них называются zip коды. Протокол может обрабатывать и другие коды, но американские коды уже заложены в демо программу.</p>
Для тех, кто находится за пределами Соединенных Штатов Америки и не знаком с их системой,&nbsp; zip это почтовый код в США, который указывает регион доставки. Zip коды цифровые и состоят из 5 цифр. Zip коды могут также содержать дополнительные четыре цифры в формате 16412-0312. Данный тип кодов получил название Zip+4. Четыре дополнительные цифры уточняют локальную зону доставки и не требуются для определения города.</p>
При создании протокола были приняты следующие решения:</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>Все команды текстовые</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>Транспорт TCP</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>Порты: 6000. Порт 6000 это наиболее часто используемый номер в тестовых примерах Indy. Это не имеет значения.</td></tr></table></div>Протокол поддерживает следующие команды</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>Help &#8211; получение справки</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>Lookup &lt;почтовый код 1&gt; &lt; почтовый код 2&gt; ... &#8211; запрос информации</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">&#183;</td><td>Quit &#8211; отсоединение от сервера</td></tr></table></div>При разработке протокола, полезно знать ключевые протоколы, такие как - NNTP, SMTP и HTTP и использовать их как модель. Исключая POP3 и IMAP4. Поскольку это плохой пример построения протоколов.</p>
Поскольку NNTP поддерживает передачу и прием сообщений в рамках одно протокола, Протокол NNTP будет упоминаться в данной книге несколько раз.</p>
10.8.1. Команда Help</p>
Команда Help очень часто используемая команда и редко применяемая в автоматических клиентах. Данная команда наиболее пригодна для использования человеком, который или тестирует, или напрямую работает с сервером. Почти все серверы реализуют данную команду.</p>
Команда Help полезна для вывода справки о командах сервера и их возможном применении.</p>
Вот пример ответа Борландовского сервера новостей сервера, на команду HELP:</p>
help</p>
100 Legal commands</p>
authinfo user Name|pass Password</p>
article [MessageID|Number]</p>
body [MessageID|Number]</p>
check MessageID</p>
date</p>
group newsgroup</p>
head [MessageID|Number]</p>
help</p>
ihave</p>
last</p>
list [active|active.times|newsgroups|subscriptions]</p>
listgroup newsgroup</p>
mode stream</p>
mode reader</p>
newgroups yymmdd hhmmss [GMT] [&lt;distributions&gt;]</p>
newnews newsgroups yymmdd hhmmss [GMT] [&lt;distributions&gt;]</p>
next</p>
post</p>
slave</p>
stat [MessageID|Number]</p>
takethis MessageID</p>
xgtitle [group_pattern]</p>
xhdr header [range|MessageID]</p>
xover [range]</p>
xpat header range|MessageID pat [morepat...]</p>
.</p>
Для нашего протокола, сервер отвечает кодом 100, плюс сопроводительный текст.</p>
10.8.2. Команда Lookup</p>
Команда lookup принимает один или несколько почтовых кодов для поиска и возвращает название города и штат. Данные возвращаются в формате RFC откликов. Если код не найден, то отклик не возвращается (но если судить по примеру это не так, возвращает пустой отклик &#8211; строка с точкой). Код ответа "200 Ok".</p>
Пример:</p>
lookup 37642 16412</p>
200 Ok</p>
37642: CHURCH HILL, TN</p>
16412: EDINBORO, PA</p>
.</p>
Даже если код не найден, то возвращается ответ "200 Ok".</p>
lookup 99999</p>
200 Ok</p>
.</p>
Мы приняли такое решение. Если бы сервер мог воспринимать только один параметр, то можно бы было отвечать кодом 200, и если не найден, то кодом 4XX. Но протокол может возвращать часть для правильных данных, поэтому было решено всегда возвращать код 200.</p>
При частично правильных данных и ответ:</p>
lookup 37642 99999</p>
200 Ok</p>
37642: CHURCH HILL, TN</p>
.</p>
Если бы протокол возвращал код ошибки, то частичные данные были бы проигнорированы. Данное решение позволило серверу отвечать и на частично правильные запросы, без генерации ошибки.</p>
10.8.3. Команда Quit</p>
Команда quit является прямым приказом серверу прекратить сессию и отсоединиться.</p>
Посмотрим снова на сервер новостей Борланда. Его ответ следующий:</p>
quit</p>
205 closing connection - goodbye!</p>
The postal code protocol responds similarly:</p>
quit</p>
201-Paka!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Russians are everywhere J)</p>
201 2 requests processed.</p>
Почтовый протокол выдает многострочные ответы. Это не определено самим протоколом. Любые RFC ответы могут быть как однострочными, так и многострочными. Indy обрабатывает оба типа ответов автоматически.</p>
&nbsp;</p>
</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
