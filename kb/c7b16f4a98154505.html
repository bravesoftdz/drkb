<html>
<head>
  <title>Вид сверху</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Вид сверху</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->

<p>9. Вид сверху</p>
ВВЕДЕНИЕ </p>
В предыдущих главах мы изучили многие из методов, необходимых для создания полноценного компилятора. Мы разработали операции присваивания (с булевыми и арифметическими выражениями), операторы отношений и управляющие конструкции. Мы все еще не обращались к вопросу вызова процедур и функций, но даже без них мы могли бы в принципе создать мини-язык. Я всегда думал, что было бы забавно просто посмотреть, насколько маленьким можно было бы построить язык, чтобы он все еще оставался полезным. Теперь мы уже почти готовы сделать это. Существует проблема: хотя мы знаем, как анализировать и транслировать конструкции, мы все еще совершенно не знаем, как сложить их все вместе в язык. </p>
В этих ранних главах разработка наших программ имела явно восходящий характер. В случае с синтаксическим анализом выражений, например, мы начали с самых низкоуровневых конструкций, индивидуальных констант и переменных и прошли свой путь до более сложных выражений. </p>
Большинство людей считают, что нисходящий способ разработки лучше, чем восходящий. Я тоже так думаю, но способ, который мы использовали, казался естественно достаточным для тех вещей, которые мы анализировали. </p>
Тем не менее вы не должны думать, что последовательный подход, который мы применяли во всех этих главах, является принципиально восходящим. В этой главе я хотел бы показать вам, что этот подход может работать точно также, когда применяется сверху вниз... может быть даже лучше. Мы рассмотрим языки типа C и Pascal и увидим как могут быть построены законченные компиляторы начиная сверху. </p>
В следующей главе мы применим ту же самую методику для создания законченного транслятора подмножества языка KISS, который я буду называть TINY. Но одна из моих целей в этой серии состоит в том, чтобы вы не только могли увидеть как работает компилятор для TINY или KISS, но чтобы вы также могли разрабатывать и создавать компиляторы своих собственных языков. Примеры Си и Паскаля помогут вам в этом. Одна вещь, которую я хотел чтобы вы увидели, состоит в том, что естественная структура компилятора очень сильно зависит от транслируемого языка, поэтому простота и легкость конструирования компилятора очень сильно зависит от того, позволите ли вы языку определять структуру программы. </p>
Немного сложнее получить полный компилятор C или Pascal, да мы и не будем. Но мы можем расчистить верхние уровни так, чтобы вы увидели как это делается. </p>
Давайте начнем. </p>
ВЕРХНИЙ УРОВЕНЬ </p>
Одна из самых больших ошибок людей при нисходящем проектировании заключается в неправильном выборе истинной вершины. Они думают, что знают какой должна быть общая структура проекта и поэтому они продолжают  и записывают ее. </p>
Всякий раз, когда я начинаю новый проект, я всегда хочу сделать это в самом начале. На языке разработки программ (program design language - PDL) этот верхний уровень походит на что-нибудь вроде: </p>
     begin </p>
       solve the problem </p>
     end </p>
Конечно, я соглашусь с вами, что это не слишком большая подсказка о том, что расположено на следующем уровне, но я все равно запишу это просто для того, чтобы  почувствовать, что я действительно начинаю с вершины. </p>
В нашем случае, общая функция компилятора заключается в компиляции законченной программы. С этого начинается любое определение языка, записанное в БНФ. На что походит верхний уровень БНФ? Хорошо, это немного зависит от транслируемого языка. </p>
Давайте взглянем на Pascal. </p>
СТРУКТУРА ПАСКАЛЯ </p>
Большинство книг по Pascal включают БНФ определение языка. Вот несколько первых строк одного из них: </p>
     &lt;program&gt; ::= &lt;program-header&gt; &lt;block&gt; '.' </p>
     &lt;program-header&gt; ::= PROGRAM &lt;ident&gt; </p>
     &lt;block&gt; ::= &lt;declarations&gt; &lt;statements&gt; </p>
Мы можем написать подпрограммы распознавания для работы с каждым из этих элементов подобно тому, как мы делали это прежде. Для каждого из них мы будем      использовать знакомые нам одно-символьные токены, затем понемногу расширяя их. Давайте начнем с первого распознавателя: непосредственно программы. </p>
Для ее трансляции мы начнем с новой копии Cradle. Так как мы возвращаемся к одно-символьным именам мы будем просто использовать "p" для обозначения "program". </p>
К новой копии Cradle добавьте следующий код и вставьте обращение к нему из основной программы: </p>
<pre name="code" class="delphi">
{ Parse and Translate A Program } 
procedure Prog; 
var  Name: char; 
begin 
   Match('p');            { Handles program header part } 
   Name := GetName; 
   Prolog(Name); 
   Match('.'); 
   Epilog(Name); 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Процедуры Prolog и Epilog выполняют все, что необходимо для связи программы с операционной системой так чтобы она могла выполняться как программа. Само собой разумеется, эта часть будет очень ОС-зависима. Помните, что я выдаю код для 68000, работающий под ОС, которую я использую - SK*DOS. Я понимаю, что большинство из вас использует PC и вы предпочли бы увидеть что-нибудь другое, но я слишком далеко зашел, чтобы что-то сейчас менять! </p>
В любом случае, SK*DOS особенно простая для общения операционная система. Вот код для Prolog и Epilog: </p>
<pre name="code" class="delphi">
{ Write the Prolog } 
procedure Prolog; 
begin 
   EmitLn('WARMST EQU $A01E'); 
end; 
 
{ Write the Epilog } 
procedure Epilog(Name: char); 
begin 
   EmitLn('DC WARMST'); 
   EmitLn('END ' + Name); 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Как обычно добавьте этот код и испытайте "компилятор". В настоящее время существует только одна допустимая входная последовательность: </p>
     px. (где х - это любая одиночная буква, имя программы). </p>
Хорошо, как обычно наша первая попытка не очень впечатляет, но я уверен к настоящему времени вы знаете, что дальше станет интересней. Есть одна важная вещь, которую следует отметить: на выходе получается работающая, законченная и выполнимая программа (по крайней мере после того, как она будет ассемблирована). </p>
Это очень важно. Приятная особенность нисходящего метода состоит в том, что на любом этапе вы можете компилировать подмножество завершенного языка и получить программу, которая будет работать на конечной машине. Отсюда, затем, нам необходимо только добавлять возможности, расширяя конструкции языка. Это очень похоже на то, что мы уже делали, за исключением того, что мы подходили к этому с другого конца. </p>
РАСШИРЕНИЕ </p>
Чтобы расширить компилятор мы должны просто работать с возможностями языка последовательно. Я хочу начать с пустой процедуры, которая ничего не делает, затем добавлять детали в пошаговом режиме. Давайте начнем с обработки блока в соответствии с его PDL выше. Мы можем сделать это в два этапа. Сначала добавьте пустую процедуру: </p>
<pre name="code" class="delphi">
{ Parse and Translate a Pascal Block } 
procedure DoBlock(Name: char); 
begin 
end; 
</pre>
<p>     и измените Prog следующим образом: </p>
<pre name="code" class="delphi">
{ Parse and Translate A Program } 
procedure Prog; 
var  Name: char; 
begin 
   Match('p'); 
   Name := GetName; 
   Prolog; 
   DoBlock(Name); 
   Match('.'); 
   Epilog(Name); 
end; 
</pre>
&nbsp;</p>
Это конечно не должно изменить поведения программы, и не меняет. Но сейчас определение Prog закончено и мы можем перейти к расширению DoBlock. Это получается прямо из его БНФ определения: </p>
<pre name="code" class="delphi">
{ Parse and Translate a Pascal Block } 
procedure DoBlock(Name: char); 
begin 
   Declarations; 
   PostLabel(Name); 
   Statements; 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Процедура PostLabel была определена в главе по ветвлениям. Скопируйте ее в вашу копию Cradle. </p>
Я возможно должен объяснить причину вставки метки. Это имеет отношение к работе SK*DOS. В отличие от некоторых других ОС, SK*DOS позволяет точке входа в основную программу находиться в любом месте программы. Все, что вы должны сделать, это дать этой точке имя. Вызов PostLabel помещает это имя как раз перед первым выполнимым утверждением в основной программе. Как SK*DOS узнает какая из множества меток является точкой входа, спросите вы? Та, которая соответствует утверждению END в конце программы. </p>
Теперь нам нужны заглушки для процедур Declarations и Statements. Сделайте их пустыми процедурами как мы делали это раньше. </p>
Программа все еще делает то же самое? Тогда мы можем перейти к следующему этапу. </p>
ОБЪЯВЛЕНИЯ </p>
БНФ для объявлений в Pascal такая: </p>
     &lt;declarations&gt; ::= ( &lt;label list&gt;    | </p>
                          &lt;constant list&gt; | <br>
                          &lt;type list&gt;     | <br>
                          &lt;variable list&gt; | <br>
<p>                          &lt;procedure&gt;     | </p>
                          &lt;function&gt;         )* </p>
(Заметьте, что я использую более либеральное определение, используемое в Turbo Pascal. В определении стандартного Pascal каждая из этих частей должна следовать в определенном порядке относительно других). </p>
Как обычно давайте позволим одиночным символам представлять каждый из этих типов объявлений. Новая форма для Declarations: </p>
<pre name="code" class="delphi">
{ Parse and Translate the Declaration Part } 
procedure Declarations; 
begin 
   while Look in ['l', 'c', 't', 'v', 'p', 'f'] do 
      case Look of 
       'l': Labels; 
       'c': Constants; 
       't': Types; 
       'v': Variables; 
       'p': DoProcedure; 
       'f': DoFunction; 
      end; 
end; 
</pre>
&nbsp;</p>
&nbsp;</p>
&nbsp;</p>
Конечно, нам нужны процедуры-заглушки для каждого из этих типов объявлений. На этот раз они не могут быть совсем пустыми процедурами, так как иначе мы останемся с бесконечным циклом While. По крайней мере каждая подпрограмма распознавания должна съедать символ, который вызывает ее. Вставьте следующие процедуры: </p>
<pre name="code" class="delphi">
{ Process Label Statement } 
procedure Labels; 
begin 
   Match('l'); 
end; 
 
{ Process Const Statement } 
procedure Constants; 
begin 
   Match('c'); 
end; 
 
{ Process Type Statement } 
procedure Types; 
begin 
   Match('t'); 
end; 
 
{ Process Var Statement } 
procedure Variables; 
begin 
   Match('v'); 
end; 
 
{ Process Procedure Definition } 
procedure DoProcedure; 
begin 
   Match('p'); 
end; 
 
{ Process Function Definition } 
procedure DoFunction; 
begin 
   Match('f'); 
end; 
</pre>
&nbsp;</p>
&nbsp;</p>
&nbsp;</p>
Теперь испытайте компилятор используя несколько характерных входных последовательностей. Вы можете смешивать объявления любым образом, каким вам нравится пока последним символом в программе не будет ".", указывающий на конец программы. Конечно, ни одно из этих объявлений фактически ничего не объявляет, так что вам не нужны (и вы не можете использовать) любые символы, кроме тех, которые обозначают ключевые слова. </p>
Мы можем расширить раздел операторов аналогичным способом. БНФ для него будет: </p>
     &lt;statements&gt; ::= &lt;compound statement&gt; </p>
     &lt;compound statement&gt; ::= BEGIN &lt;statement&gt;(';' &lt;statement&gt;) END </p>
Заметьте, что утверждение может начинаться с любого идентификатора, исключая END.  Так что первая пустой формой процедуры Statements будет: </p>
<pre name="code" class="delphi">
{ Parse and Translate the Statement Part } 
procedure Statements; 
begin 
   Match('b'); 
   while Look &lt;&gt; 'e' do 
      GetChar; 
   Match('e'); 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Сейчас компилятор примет любое число объявлений, сопровождаемое блоком BEGIN основной программы. Сам этот блок может содержать любые символы (за исключением END), но они должны присутствовать. </p>
Простейшая входная форма сейчас </p>
     'pxbe.' </p>
Испытайте ее. Также попробуйте некоторые ее комбинации. Сделайте некоторые преднамеренные ошибки и посмотрите что произойдет. </p>
К этому моменту вы должны начать видеть основную линию. Мы начинаем с пустого транслятора для обработки программы, затем в свою очередь мы расширяем каждую процедуру,  основанную на ее БНФ определении. Подобно тому, как более низкоуровневые БНФ определения добавляют детали и развивают определения более высокого уровня, более низкоуровневые распознаватели будут анализировать более детально входную программу. Когда последняя заглушка будет расширена, компилятор будет закончен. Это нисходящая разработка/реализация в ее чистейшей форме. </p>
Вы могли бы заметить, что даже хотя мы и добавляли процедуры, выходной результат программы не изменялся. Так и должно быть. На этих верхних уровнях не требуется никакой выдачи кода. Распознаватели функционируют просто как распознаватели. Они принимают входные последовательности, отлавливают плохие и направляют хорошие в нужные места, так что они делают свою работу. Если бы мы занимались этим немного дольше, код начал бы появляться. </p>
Следующим шагом в нашем расширении должна возможно быть процедура Statements. </p>
Определение Pascal: </p>
     &lt;statement&gt; ::= &lt;simple statement&gt; | &lt;structured statement&gt; </p>
     &lt;simple statement&gt; ::= &lt;assignment&gt; | &lt;procedure call&gt; | null </p>
     &lt;structured statement&gt; ::= &lt;compound statement&gt; | <br>
                               &lt;if statement&gt;       | <br>
                               &lt;case statement&gt;     | <br>
                               &lt;while statement&gt;    | <br>
                               &lt;repeat statement&gt;   | <br>
<p>                               &lt;for statement&gt;      | </p>
                               &lt;with statement&gt; </p>
Это начинает выглядеть знакомыми. Фактически вы уже прошли через процесс синтаксического анализа и генерации кода и для операций присваивания и для управляющих структур. Это место, где верхний уровень встречается с нашим восходящим методом из предыдущих уроков. Конструкции будут немного отличаться от тех, которые мы использовали для KISS, но в этих различиях нет ничего, чего бы вы не смогли сделать. </p>
Я думаю теперь вы можете получить представление об этом процессе. Мы начали с завершенного БНФ описания языка. Начиная с верхнего уровня мы закодировали распознаватели для этих БНФ утверждений используя процедуры-заглушки для распознавателей следующего уровня. Затем мы расширили более низкоуровневые утверждения один за другим. </p>
Как оказывается, определение Pascal очень совместимо с использованием БНФ и БНФ описания этого языка существуют в избытке. Вооружившись таким описанием вы обнаружите, что довольно просто продолжить процесс, который мы начали. </p>
Вы могли бы продолжить расширение этих конструкций, просто чтобы прочувствовать это. Я не ожидаю, что вы сможет завершить сейчас компилятор Паскаля... есть слишком много вещей, таких как процедуры и типы, к которым мы еще не обращались... но могло бы быть полезным попробовать некоторые из более знакомых вещей. Вам было бы полезно увидеть выполнимые программы, появляющиеся с другого конца. </p>
Если бы я собирался обратиться к вопросам которые мы еще не охватили, я предпочел бы сделать это в контексте KISS. Мы не пытаемся построить полный компилятор Pascal, поэтому я собираюсь остановить на этом расширение Pascal. Давайте взглянем на очень отличающийся язык. </p>
СТРУКТУРА   СИ </p>
Язык C совсем другой вопрос, как вы увидите. Книги по C редко включают БНФ определения языка. Возможно дело в том, что этот язык очень сложен для описания в БНФ. </p>
Одна из причин что я показываю вам сейчас эти структуры в том что я могу впечатлить вас двумя фактами: </p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">1.</td><td>Определение языка управляет структурой компилятора. Что работает для одного языка может быть бедствием для другого. Это очень плохая идея попытаться принудительно встроить данную структуру в компилятор. Скорее вы должны позволить БНФ управлять структурой, как мы делали здесь. </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr ><td width="24">2.</td><td>Язык, для которого сложно написать БНФ также будет возможно сложен для написания компилятора. Си - популярный язык и он имеет репутацию как позволяющий сделать практически все, что возможно. Несмотря на успех Small С, С является непростым для анализа языком. </td></tr></table></div>Программа на C имеет меньше структур, чем ее аналог на Pascal. На верхнем уровне все в C является статическим объявлением или данных или функций. Мы можем зафиксировать эту мысль так: </p>
     &lt;program&gt; ::= ( &lt;global declaration&gt; )* </p>
     &lt;global declaration&gt; ::= &lt;data declaration&gt; | &lt;function&gt; </p>
В Small C функции могут иметь только тип по умолчанию int, который не объявлен. Это делает входную программу легкой для синтаксического анализа: первым токеном является или "int", "char" или имя функции. В Small C команды препроцессора также обрабатываются компилятором соответствующе, так что синтаксис становится: </p>
     &lt;global declaration&gt; ::= '#' &lt;preprocessor command&gt;  | </p>
                         'int' &lt;data list&gt;           | <br>
<p>                         'char' &lt;data list&gt;          | </p>
                         &lt;ident&gt; &lt;function body&gt;     | </p>
Хотя мы в действительности больше заинтересованы здесь в полном C , я покажу вам код, соответствующий структуре верхнего уровня Small C. </p>
<pre name="code" class="delphi">
{ Parse and Translate A Program } 
procedure Prog; 
begin 
   while Look &lt;&gt; ^Z do begin 
      case Look of 
       '#': PreProc; 
       'i': IntDecl; 
       'c': CharDecl; 
      else DoFunction(Int); 
      end; 
   end; 
end; 
</pre>
&nbsp;</p>
&nbsp;</p>
&nbsp;</p>
Обратите внимание, что я должен был использовать ^Z чтобы указать на конец исходного кода. C не имеет ключевого слова типа END или "." для индикации конца программы. </p>
С полным Си все не так просто. Проблема возникает потому, что в полном Си функции могут также иметь типы. Так что когда компилятор видит ключевое слово типа "int" он все еще не знает ожидать ли объявления данных или определение функции. Дела становятся более сложными так как следующим токеном может быть не имя... он может начинаться с "*" или "(" или комбинаций этих двух. </p>
Точнее говоря, БНФ для полного Си начинается с: </p>
     &lt;program&gt; ::= ( &lt;top-level decl&gt; )* </p>
     &lt;top-level decl&gt; ::= &lt;function def&gt; | &lt;data decl&gt; </p>
     &lt;data decl&gt; ::= [&lt;class&gt;] &lt;type&gt; &lt;decl-list&gt; </p>
     &lt;function def&gt; ::= [&lt;class&gt;] [&lt;type&gt;] &lt;function decl&gt; </p>
Теперь вы можете увидеть проблему: первые две части объявлений для данных и функций могут быть одинаковыми. Из-за неоднозначности в этой грамматике выше, она является неподходящей для рекурсивного синтаксического анализатора. Можем ли мы преобразовать ее в одну из подходящих? Да, с небольшой работой. Предположим мы запишем ее таким образом: </p>
     &lt;top-level decl&gt; ::= [&lt;class&gt;] &lt;decl&gt; </p>
     &lt;decl&gt; ::= &lt;type&gt; &lt;typed decl&gt; | &lt;function decl&gt; </p>
     &lt;typed decl&gt; ::= &lt;data list&gt; | &lt;function decl&gt; </p>
Мы можем написать подпрограмму синтаксического анализа для определений классов и типов и позволять им отложить их сведения и продолжать выполнение даже не зная обрабатывается ли функция или объявление данных. </p>
Для начала, наберите следующую версию основной программы: </p>
<pre name="code" class="delphi">
{ Main Program } 
begin 
   Init; 
   while Look &lt;&gt; ^Z do begin 
      GetClass; 
      GetType; 
      TopDecl; 
   end; 
end.
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
На первый раз просто сделайте три процедуры-заглушки которые ничего не делают, а только вызывают GetChar. </p>
Работает ли эта программа? Хорошо, было бы трудно не сделать это, так как мы в действительности не требовали от нее какой-либо работы. Уже говорилось, что компилятор Си примет практически все без отказа. Несомненно это правда для этого компилятора, потому что в действительности все, что он делает, это съедает входные символы до тех пор, пока не найдет ^Z. </p>
Затем давайте заставим GetClass делать что-нибудь стоящее. Объявите глобальную переменную </p>
     var Class: char; </p>
и измените GetClass </p>
<pre name="code" class="delphi">
{  Get a Storage Class Specifier } 
Procedure GetClass; 
begin 
   if Look in ['a', 'x', 's'] then begin 
      Class := Look; 
      GetChar; 
      end 
   else Class := 'a'; 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Здесь я использовал три одиночных символа для представления трех классов памяти "auto", "extern" и "static". Это не единственные три возможных класса... есть также "register" и "typedef", но это должно дать вам представление. Заметьте, что класс по умолчанию "auto". </p>
Мы можем сделать подобную вещь для типов. Введите следующую процедуру: </p>
<pre name="code" class="delphi">
{  Get a Type Specifier } 
procedure GetType; 
begin 
   Typ := ' '; 
   if Look = 'u' then begin 
      Sign := 'u'; 
      Typ := 'i'; 
      GetChar; 
      end 
   else Sign := 's'; 
   if Look in ['i', 'l', 'c'] then begin 
      Typ := Look; 
      GetChar; 
   end; 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Обратите внимание, что вы должны добавить еще две глобальные переменные Sign и Typ. </p>
С этими двумя процедурами компилятор будет обрабатывать определение классов и типов и сохранять их результаты. Мы можем сейчас обрабатывать остальные объявления. </p>
Мы еще ни коим образом не выбрались из леса, потому что все еще существуют много сложностей только в определении типов до того, как мы дойдем даже до фактических данных или  имен функций. Давайте притворимся на мгновение, что мы прошли все эти заслоны и следующим во входном потоке является имя. Если имя сопровождается левой скобкой, то мы имеем объявление функции. Если нет, то мы имеем по крайней мере один элемент данных, и возможно список, каждый элемент которого может иметь инициализатор. </p>
Вставьте следующую версию TopDecl: </p>
<pre name="code" class="delphi">
{ Process a Top-Level Declaration } 
procedure TopDecl; 
var Name: char; 
begin 
   Name := Getname; 
   if Look = '(' then 
      DoFunc(Name) 
   else 
      DoData(Name); 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
(Заметьте, что так как мы уже прочитали имя, мы должны передать его соответствующей подпрограмме.) </p>
Наконец, добавьте две процедуры DoFunc и DoData: </p>
<pre name="code" class="delphi">
{ Process a Function Definition } 
procedure DoFunc(n: char); 
begin 
   Match('('); 
   Match(')'); 
   Match('{'); 
   Match('}'); 
   if Typ = ' ' then Typ := 'i'; 
   Writeln(Class, Sign, Typ, ' function ', n); 
end; 
 
{ Process a Data Declaration } 
procedure DoData(n: char); 
begin 
   if Typ = ' ' then Expected('Type declaration'); 
   Writeln(Class, Sign, Typ, ' data ', n); 
   while Look = ',' do begin 
      Match(','); 
      n := GetName; 
      WriteLn(Class, Sign, Typ, ' data ', n); 
   end; 
   Match(';'); 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Так как мы еще далеки от получения выполнимого кода, я решил чтобы эти две подпрограммы только сообщали нам, что они нашли. </p>
Протестируйте эту программу. Для объявления данных дайте список, разделенный запятыми. Мы не можем пока еще обрабатывать инициализаторы. Мы также не можем обрабатывать списки параметров функций но символы "(){}" должны быть. </p>
Мы все еще очень далеко от того, чтобы иметь компилятор C, но то что у нас есть обрабатывает правильные виды входных данных и распознает и хорошие и плохие входных данные. В процессе этого естественная структура компилятора начинает принимать форму. </p>
Можем ли мы продолжать пока не получим что-то, что действует более похоже на компилятор. Конечно мы можем. Должны ли мы? Это другой вопрос. Я не знаю как вы, но у меня начинает кружиться голова, а мы все еще далеки от того, чтобы даже получить что-то кроме объявления данных. </p>
К этому моменту, я думаю, вы можете видеть как структура компилятора развивается из определения языка. Структуры, которые мы увидели для наших двух примеров, Pascal и C, отличаются как день и ночь. Pascal был разработан, по крайней мере частично, чтобы быть легким для синтаксического анализа и это отразилось в компиляторе. Вообще, Pascal более структурирован и мы имеем более конкретные идеи какие виды конструкций ожидать в любой точке. В C наоборот, программа по существу является списком объявлений завершаемых только концом файла. </p>
Мы могли бы развивать обе эти структуры намного дальше, но помните, что наша цель здесь не в том, чтобы построить компилятор C или Pascal, а скорее изучать компиляторы вообще. Для тех из вас, кто хотят иметь дело с Pascal или C, я надеюсь, что дал вам достаточно начал чтобы вы могли взять их отсюда (хотя вам скоро понадобятся некоторые вещи, которые мы еще не охватили здесь, такие как типы и вызовы процедур). Остальные будьте со мной в следующей главе. Там я проведу вас через разработку законченного компилятора для TINY, подмножества KISS. </p>
&nbsp;</p>
</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
