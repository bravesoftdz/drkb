<html>
<head>
  <title>Работа с таблицами в коде</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
  <link type="text/css" href="css/css.css" rel="stylesheet" />
  <link type="text/css" href="css/sh.css" rel="stylesheet" />
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <div id="logo"><img id="logo" src="img/logo.png" /></div>
  <div id="navigation">
    <p id="navigation">
      <a class="navigation" onclick="prev();" href="#">Предыдущая</a><br />
      <a class="navigation" onclick="up();" href="#">Наверх</a><br />
      <a class="navigation" onclick="next();" href="#">Следующая</a>
    </p>
  </div>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Работа с таблицами в коде</h1>
<div id="date">01.01.2010</div>
<!-- Actual content start -->

<p>Пока мы рассмотрели самые простейшие и самые не эффективные операции над базами данных, которые нужны лишь в очень ограниченных случаях - их недостаток очевиден - операции роводятся только с одной записью и эти операции только визуальные. Чем это плохо? - это самый медленный способ работы с базами. Он годиться только для работы с данными в ручную, все остальные операции, которые не требуют визуализации не должны работать таким образом. </p>
<p>Итак, начинаем разбирать способы работы с базами данных в коде.</p>
<p>Прежде всего заметим, что работать мы будем только с компонентом</p>
<p>Table1. Сразу предупреждаю - КАТЕГОРИЧЕСКИ НЕ СЛЕДУЕТ ПЫТАТЬСЯ ИЗ</p>
<p>КОДА МЕНЯТЬ ЗНАЧЕНИЯ В ВИЗУАЛЬНЫХ КОМПОНЕНТАХ, не следует пытаться</p>
<p>менять или читать значения из DBGrid, DBEdit и т.д. Эти компоненты</p>
<p>существуют только для работы оператора "вручную". Для доступа к</p>
<p>данным из кода надо использовать только невизуальные компоненты</p>
<p>типа TTable (в дальнейшем мы разберём и другие компоненты для работы</p>
<p>с данными - но в любом случае это будут не визуальные компоненты).</p>
<p>Представив себе обычную таблицу, понятно что для доступа к данным</p>
<p>надо определить столбец(поле) и строку(запись) в которой эти данные</p>
<p>находятся. Давайте разбирать по очереди.</p>
<p>1) Определить поле задача очень простая. Способов здесь 2:</p>
<p>или по имени:</p>
<p>Table1.FieldByName('Category')</p>
<p>или по номеру столбца</p>
<p>Table1.Fields[1]</p>
<p>Оба выражения являются объектом наследованным от типа TField</p>
<p>Я не буду разбирать этот объект подробно, только приведу пример</p>
<p>как можно пользоваться этим объектом для доступа к содержимому</p>
<p>ячейки таблицы. Содержимое может быть разных типов, поэтому можно</p>
<p>использовать следующие методы в зависимости от типа данных:</p>
<pre name="code" class="delphi">
Table1.FieldByName('Category').AsString
Table1.FieldByName('Category').AsInteger
Table1.FieldByName('Category').AsBoolean
Table1.FieldByName('Category').AsDateTime
Table1.FieldByName('Category').AsFloat
</pre>

<p>Например, поставте на форму кнопку, и на onClick напишите</p>
<p>следующий код:</p>
<p>Showmessage(Table1.FieldByName('Category').AsString);</p>
<p>При нажатии на кнопку вы увидите содержимое столбца 'Category'</p>
<p>для текущей записи. Аналогично для обращения по номеру:</p>
<p>Showmessage(Table1.Fields[1].AsString);</p>
<p>Обратите внимание, что на этапе компилляции компиллятор абсолютно</p>
<p>не знает о реальном типе данных в поле таблицы. Это выяснится</p>
<p>только при попытке выполнить строку. Что будет если типы не</p>
<p>совпадают? Если тип можно конвертировать - то ничего страшного,</p>
<p>например если у вас поле с целым числом 123, то обращение к полю</p>
<p>через AsString выдаст результат - строку '123'. Но если типы</p>
<p>не совместимы, то будет сгенерирована ошибка, например такая строка</p>
<p>почти наверняка в нашем приложении приведёт к ошибке:</p>
<pre name="code" class="delphi">
var i:integer;
...
i:=Table1.FieldByName('Category').AsInteger;
showmessage(inttostr(i));
</pre>

<p>Потому что реальные данные не могут быть приведены к целому типу. </p>
<p>Теперь давайте разбираться как нам добраться до нужной строки,</p>
<p>другими словами, до нужной записи. Как я уже говорил мы можем</p>
<p>работать только с одной "активной" записью, поэтому задача сводится</p>
<p>к установке нужной записи "активной" (К знатокам баз данных - я упорно</p>
<p>и намеренно обхожу стороной понятие "курсор" и попытаюсь провести повествование</p>
<p>без его упоминания, с целью упрощения понимания материала и не хочу углублятся</p>
<p>в материал, без которого можно на первых порах обойтись). Итак, прежде всего</p>
<p>Table компонент имеет 4 метода которые помогут нам пройти через все строки</p>
<p>таблицы:</p>
<p>Table1.First - переход на первую запись</p>
<p>Table1.Last - переход на последнюю запись</p>
<p>Table1.Prior - переход на предыдущую запись</p>
<p>Table1.Next - переход на следующую запись</p>
<p>А так же 2 полезных свойства:</p>
<p>Table1.RecordCount - возвращает количество записей (строк) в таблице</p>
<p>Table1.Eof - возвращает TRUE если достигнута последняя запись, в остальных случаях FALSE</p>
<p>Давайте на нашу форму положим компонент Memo (на сей раз обычное, а не dbMemo).</p>
<p>Вот этот простейший код позволит пройти таблицу от начала до конца и считать</p>
<p>значения одного поля для всех записей в Memo:</p>
<pre name="code" class="delphi">
Table1.First;//переход на первую запись
While not Table1.eof do //делать цикл пока таблица не закончится
begin
Memo1.lines.add(Table1.fieldbyname('Category').AsString); //заносим в Мемо значение поля для текущей записи
Table1.Next;//переходим на следующую запись
end;
</pre>

<p>Или это же самое можно сделать например так:</p>
<pre name="code" class="delphi">
Table1.First;
For i=0 to Table1.recordcount-1 do
begin
Memo1.lines.add(Table1.fieldbyname('Category').AsString); //заносим в Мемо значение поля для текущей записи
Table1.Next;//переходим на следующую запись
end;
</pre>

<p>Второй способ гораздо хуже. Он имеет следующие недостатки:</p>
<p>1) Не для всех баз данных метод Table1.recordcount возвращает правильное</p>
<p>значение. Иногда Table1.recordcount устанавливается только после перехода на</p>
<p>последнюю запись(это не глюк, это вполне объяснимое поведение, например если у</p>
<p>вас есть хорошая табличка размером в несколько гигабайт на другом компьютере,</p>
<p>то Table вовсе не скачивает всю эту таблицу локально, а достаёт данные только</p>
<p>по мере необходимости). К счастью этот недостаток легко устраним, надо код</p>
<p>преобразовать до следующего вида:</p>
<pre name="code" class="delphi">
Table1.Last;
Table1.First;
For i=0 to Table1.recordcount-1 do
begin
Memo1.lines.add(Table1.fieldbyname('Category').AsString); //заносим в Мемо значение поля для текущей записи
Table1.Next;//переходим на следующую запись
end;
</pre>

<p>Несмотря на кажущуюся бессмысленность это работает.</p>
<p>2) А вот другой аспект - всегда надо помнить о многопользовательском</p>
<p>доступе к таблицам - что случится, если во время прохода по записям другой пользователь</p>
<p>добавит или удалит запись?</p>
</div>
<!-- Actual content end -->
<hr />
<div id="footer">
<p>&copy; DRKB Library, 2010<br />Разработка и поддержка &mdash; <a href="http://www.drkb.ru/" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
